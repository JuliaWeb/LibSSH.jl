var documenterSearchIndex = {"docs":
[{"location":"server_support/","page":"Server support","title":"Server support","text":"CurrentModule = LibSSH","category":"page"},{"location":"server_support/#Server-support","page":"Server support","title":"Server support","text":"","category":"section"},{"location":"server_support/","page":"Server support","title":"Server support","text":"The symbols documented on this page are intended to be safe. They may throw exceptions but they should never cause memory corruptions or segfaults if used correctly.","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"Pages = [\"server_support.md\"]\nDepth = 10","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"RequestType","category":"page"},{"location":"server_support/#LibSSH.RequestType","page":"Server support","title":"LibSSH.RequestType","text":"primitive type RequestType <: Enum{Int32} 32\n\nEnum for the types of SSH requests a client can send to a server:\n\nRequestType_Auth\nRequestType_ChannelOpen\nRequestType_Channel\nRequestType_Service\nRequestType_Global\n\n\n\n\n\n","category":"type"},{"location":"server_support/#SSH-Binds","page":"Server support","title":"SSH Binds","text":"","category":"section"},{"location":"server_support/","page":"Server support","title":"Server support","text":"The main type you care about for writing a server is the Bind, which is somewhat analogous to a listening socket. It can be bound to a port and when a connection is attempted by a client it can be accepted with lib.ssh_bind_accept(). Implementing everything else (including authentication) must be done yourself.","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"If you're writing a server and want to implement keyboard-interactive authentication, also see message_auth_interactive_request.","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"info: Info\nThere are some examples of using libssh's C API to write a server here (using callbacks), and another one demonstrating keyboard-interactive authentication here (not using callbacks). You can also check the source for the Demo server.","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"Bind\nlisten\nwait_for_listener\nhandle_key_exchange\nset_auth_methods(::Session, ::Vector{AuthMethod})\nset_auth_methods(::lib.ssh_message, ::Vector{AuthMethod})\nCallbacks.ServerCallbacks\nCallbacks.ServerCallbacks()\nset_server_callbacks\nset_message_callback\nget_error(::Bind)\nBase.close(::Bind)\nBase.lock(::Bind)\nBase.unlock(::Bind)\nBase.isopen(::Bind)","category":"page"},{"location":"server_support/#LibSSH.Bind","page":"Server support","title":"LibSSH.Bind","text":"mutable struct Bind\n\nptr::Union{Nothing, Ptr{LibSSH.lib.ssh_bind_struct}}\naddr::String\nport::UInt64\nhostkey::Union{Nothing, String}\nkey::Union{Nothing, LibSSH.PKI.SshKey}\nauth_methods::Vector{LibSSH.AuthMethod}\nlog_verbosity::Int64\n_listener_event::Base.Event\n_listener_started::Bool\n_lock::ReentrantLock\n_message_callback::Union{Nothing, Function}\n_message_callback_userdata::Any\n\nWrapper around lib.ssh_bind.\n\n\n\n\n\n","category":"type"},{"location":"server_support/#LibSSH.listen","page":"Server support","title":"LibSSH.listen","text":"listen(handler::Function, bind::LibSSH.Bind; poll_timeout)\n\n\nHigh-level function to listen for incoming requests and pass them off to a handler function. This will already set the auth methods on the session (from Bind.auth_methods) before calling the handler.\n\nThe poll_timeout argument refers to the timeout for polling the bind socket for new connections. It must be >0 because otherwise it would never wake up if the socket was closed while waiting, but other than that the exact value doesn't matter much. It'll only control how frequently the listen loop wakes up to check if the bind has been closed yet.\n\n\n\n\n\n","category":"function"},{"location":"server_support/#LibSSH.wait_for_listener","page":"Server support","title":"LibSSH.wait_for_listener","text":"wait_for_listener(bind::LibSSH.Bind)\n\n\nWaits for the main loop of listen to begin running on the bind.\n\n\n\n\n\n","category":"function"},{"location":"server_support/#LibSSH.handle_key_exchange","page":"Server support","title":"LibSSH.handle_key_exchange","text":"handle_key_exchange(session::LibSSH.Session) -> Bool\n\n\nNon-blocking wrapper around lib.ssh_handle_key_exchange(). Returns true or false depending on whether the exchange succeeded.\n\n\n\n\n\n","category":"function"},{"location":"server_support/#LibSSH.set_auth_methods-Tuple{LibSSH.Session, Vector{LibSSH.AuthMethod}}","page":"Server support","title":"LibSSH.set_auth_methods","text":"set_auth_methods(\n    session::LibSSH.Session,\n    auth_methods::Vector{LibSSH.AuthMethod}\n)\n\n\nSet authentication methods on a Session.\n\nWrapper around lib.ssh_set_auth_methods().\n\n\n\n\n\n","category":"method"},{"location":"server_support/#LibSSH.set_auth_methods-Tuple{Ptr{LibSSH.lib.ssh_message_struct}, Vector{LibSSH.AuthMethod}}","page":"Server support","title":"LibSSH.set_auth_methods","text":"set_auth_methods(\n    msg::Ptr{LibSSH.lib.ssh_message_struct},\n    auth_methods::Vector{LibSSH.AuthMethod}\n) -> Int32\n\n\nSet authentication methods for a lib.ssh_message.\n\nWrapper around lib.ssh_message_auth_set_methods().\n\n\n\n\n\n","category":"method"},{"location":"server_support/#LibSSH.Callbacks.ServerCallbacks","page":"Server support","title":"LibSSH.Callbacks.ServerCallbacks","text":"mutable struct ServerCallbacks\n\nWrapper around lib.ssh_server_callbacks_struct.\n\n\n\n\n\n","category":"type"},{"location":"server_support/#LibSSH.Callbacks.ServerCallbacks-Tuple{}","page":"Server support","title":"LibSSH.Callbacks.ServerCallbacks","text":"ServerCallbacks(; ...) -> LibSSH.Callbacks.ServerCallbacks\nServerCallbacks(\n    userdata;\n    on_auth_password,\n    on_auth_none,\n    on_auth_gssapi_mic,\n    on_auth_pubkey,\n    on_service_request,\n    on_channel_open_request_session\n) -> LibSSH.Callbacks.ServerCallbacks\n\n\nCreate a callbacks object to set on a server. This has basically the same behaviour as ChannelCallbacks(), except that there are some callbacks that are unsupported due to lack of documentation:\n\ngssapi_select_oid_function\ngssapi_accept_sec_ctx_function\ngssapi_verify_mic_function\n\nAnd lib.ssh_key arguments will be converted to a non-owning ssh.PKI.SshKey.\n\nwarning: Warning\nDo not use ssh.Session or ssh.PKI.SshKey arguments outside the callback functions. They are temporary non-owning wrappers, and they will be unusable after the callback has been executed.\n\nArguments\n\nAll of these are also properties that can be set after creation.\n\nuserdata: An arbitrary object that will be passed to each callback.\non_auth_password: f(::Session, ::String, ::String, userdata)::AuthStatus\non_auth_none: f(::Session, ::String, userdata)::AuthStatus\non_auth_gssapi_mic: f(::Session, ::String, ::String, userdata)::AuthStatus\non_auth_pubkey: f(::Session, ::String, ::SshKey, ::Char, userdata)::AuthStatus\non_service_request: f(::Session, ::String, userdata)::Bool\non_channel_open_request_session: f(::Session, userdata)::Union{SshChannel, Nothing}\n\n\n\n\n\n","category":"method"},{"location":"server_support/#LibSSH.set_server_callbacks","page":"Server support","title":"LibSSH.set_server_callbacks","text":"set_server_callbacks(\n    session::LibSSH.Session,\n    callbacks::LibSSH.Callbacks.ServerCallbacks\n) -> LibSSH.Callbacks.ServerCallbacks\n\n\nSet callbacks for a Session. Wrapper around lib.ssh_set_server_callbacks().\n\n\n\n\n\n","category":"function"},{"location":"server_support/#LibSSH.set_message_callback","page":"Server support","title":"LibSSH.set_message_callback","text":"set_message_callback(\n    f::Function,\n    bind::LibSSH.Bind,\n    userdata\n)\n\n\nSet message callbacks for the sessions accepted by a Bind. This must be set before listen is called to take effect. listen will automatically set the callback before passing the session to the user handler.\n\nThe callback function must have the signature:\n\nf(session::Session, msg::lib.ssh_message, userdata)::Bool\n\nThe return value indicates whether further handling of the message is necessary. It should be true if the message wasn't handled or needs to be handled by libssh, or false if the message was completely handled and doesn't need any more action from libssh.\n\n\n\n\n\n","category":"function"},{"location":"server_support/#LibSSH.get_error-Tuple{LibSSH.Bind}","page":"Server support","title":"LibSSH.get_error","text":"get_error(bind::LibSSH.Bind) -> String\n\n\nGet the last error set by libssh. Wrapper around lib.ssh_get_error().\n\n\n\n\n\n","category":"method"},{"location":"server_support/#Base.close-Tuple{LibSSH.Bind}","page":"Server support","title":"Base.close","text":"close(bind::LibSSH.Bind)\n\n\nClose and free the bind.\n\n\n\n\n\n","category":"method"},{"location":"server_support/#Base.lock-Tuple{LibSSH.Bind}","page":"Server support","title":"Base.lock","text":"lock(bind::LibSSH.Bind)\n\n\nLock a bind for thread-safe operations.\n\n\n\n\n\n","category":"method"},{"location":"server_support/#Base.unlock-Tuple{LibSSH.Bind}","page":"Server support","title":"Base.unlock","text":"unlock(bind::LibSSH.Bind)\n\n\nUnlock a bind.\n\n\n\n\n\n","category":"method"},{"location":"server_support/#Base.isopen-Tuple{LibSSH.Bind}","page":"Server support","title":"Base.isopen","text":"isopen(bind::LibSSH.Bind) -> Bool\n\n\nCheck if the bind has been free'd yet.\n\n\n\n\n\n","category":"method"},{"location":"server_support/","page":"Server support","title":"Server support","text":"","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"Each Session accepted by a Bind must be polled for all the handlers to execute. This is possible through the SessionEvent type.","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"SessionEvent\nSessionEvent(::Session)\nevent_dopoll\nBase.isassigned(::SessionEvent)\nBase.close(::SessionEvent)","category":"page"},{"location":"server_support/#LibSSH.SessionEvent","page":"Server support","title":"LibSSH.SessionEvent","text":"mutable struct SessionEvent\n\nptr::Union{Nothing, Ptr{LibSSH.lib.ssh_event_struct}}\nsession::LibSSH.Session\nlock::ReentrantLock\n\nThis object wraps a lib.ssh_event, but it's designed to only allow adding a single session to it. Use this in a server to poll the session. It is threadsafe.\n\n\n\n\n\n","category":"type"},{"location":"server_support/#LibSSH.SessionEvent-Tuple{LibSSH.Session}","page":"Server support","title":"LibSSH.SessionEvent","text":"SessionEvent(session::LibSSH.Session) -> LibSSH.SessionEvent\n\n\nCreate an empty SessionEvent.\n\n\n\n\n\n","category":"method"},{"location":"server_support/#LibSSH.event_dopoll","page":"Server support","title":"LibSSH.event_dopoll","text":"event_dopoll(event::LibSSH.SessionEvent) -> Any\n\n\nNon-blocking wrapper around lib.ssh_event_dopoll(). This may trigger callbacks on the session and its channels.\n\nReturns either SSH_OK or SSH_ERROR.\n\n\n\n\n\n","category":"function"},{"location":"server_support/#Base.isassigned-Tuple{LibSSH.SessionEvent}","page":"Server support","title":"Base.isassigned","text":"isassigned(event::LibSSH.SessionEvent) -> Bool\n\n\nCheck if a SessionEvent holds a valid pointer to a lib.ssh_event.\n\n\n\n\n\n","category":"method"},{"location":"server_support/#Base.close-Tuple{LibSSH.SessionEvent}","page":"Server support","title":"Base.close","text":"close(event::LibSSH.SessionEvent; unsafe)\n\n\nRemoves the Session from the underlying ssh_event and frees the event memory. This function may be safely called multiple times, and the event will be unusable afterwards.\n\n\n\n\n\n","category":"method"},{"location":"server_support/#Demo-server","page":"Server support","title":"Demo server","text":"","category":"section"},{"location":"server_support/","page":"Server support","title":"Server support","text":"The DemoServer is an extremely simple and limited implementation of an SSH server using the libssh server API. It's sole reason for existence is to be used in test suites to test client code. Do not expose this publicly! See the constructors docstrings for examples of how to use it (the LibSSH.jl test suite may also be informative).","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"Supported features:","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"Password authentication: only the password is checked, not the username.\nKeyboard-interactive authentication: the server will give two prompts for a Password: and Token: and expect foo and bar as answers, respectively.\nCommand execution: note that requested environment variables from the client are currently ignored, and the command output will only be sent back to the client after the command has finished.\nDirect port forwarding","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"Unsupported features (that may be implemented in the future):","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"Public key authentication\nGSSAPI authentication\nReverse port forwarding","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"One might ask the question, why use a demo server for testing instead of something battle-hardened like sshd? Well, turns out that it's impossible to run sshd as a non-root user unless you disable password authentication (because sshd needs to read /etc/passwd), which is definitely something we want to test. Plus, having a custom server makes it simpler to set up in just the way we want.","category":"page"},{"location":"server_support/","page":"Server support","title":"Server support","text":"Modules = [LibSSH.Demo]","category":"page"},{"location":"server_support/#LibSSH.Demo.DemoServer","page":"Server support","title":"LibSSH.Demo.DemoServer","text":"mutable struct DemoServer\n\nbind::LibSSH.Bind\nlistener_task::Union{Nothing, Task}\nsshchan::Union{Nothing, LibSSH.SshChannel}\nverbose::Bool\npassword::Union{Nothing, String}\nallow_auth_none::Bool\nclients::Vector{LibSSH.Demo.Client}\n\n\n\n\n\n","category":"type"},{"location":"server_support/#LibSSH.Demo.DemoServer-Tuple{Function, Vararg{Any}}","page":"Server support","title":"LibSSH.Demo.DemoServer","text":"DemoServer(\n    f::Function,\n    args...;\n    timeout,\n    kill_timeout,\n    kwargs...\n) -> Tuple{Any, Any}\n\n\nDo-constructor to execute a function f() while the server is running and have it safely cleaned up afterwards. There are two keyword arguments to be aware of:\n\ntimeout (default 10s): set a timeout in seconds for f(). If f() doesn't finish before the timeout an InterruptException will be thrown to it.\nkill_timeout (default 3s): set a waiting time in seconds for f() to exit after throwing it an InterruptException. Sometimes you may want to cleanup things before exiting, and this gives some time to do that. If f() isn't finished after kill_timeout no futher action will be taken.\n\nargs and kwargs will all be passed to DemoServer(::Int).\n\nExamples\n\njulia> import LibSSH.Demo: DemoServer\n\njulia> DemoServer(2222; password=\"foo\") do\n           run(`sshpass -p foo ssh -o NoHostAuthenticationForLocalhost=yes -p 2222 localhost echo 'Hello world!'`)\n       end\nHello world!\n\n\n\n\n\n","category":"method"},{"location":"server_support/#LibSSH.Demo.DemoServer-Tuple{Int64}","page":"Server support","title":"LibSSH.Demo.DemoServer","text":"DemoServer(\n    port::Int64;\n    verbose,\n    password,\n    allow_auth_none,\n    auth_methods,\n    log_verbosity\n) -> LibSSH.Demo.DemoServer\n\n\nCreates a DemoServer.\n\nArguments\n\nport: The port to listen to.\nverbose=false: This verbosity doesn't refer to the log messages from libssh but from the DemoServer. If this is true it print messages on events like authentication etc. Useful for high-level debugging. The events can always be printed afterwards with Demo.print_timeline.\npassword=nothing: The password to use if password authentication is enabled.\nallow_auth_none: Whether to allow authentication without any credentials being presented.\nauth_methods=[AuthMethod_None, AuthMethod_Password]: A list of authentication methods to enable. See ssh.AuthMethod.\nlog_verbosity=nothing: Controls the logging of libssh itself. This could be e.g. lib.SSH_LOG_WARNING (see the upstream documentation).\n\n\n\n\n\n","category":"method"},{"location":"server_support/#LibSSH.Demo.print_timeline-Tuple{LibSSH.Demo.DemoServer}","page":"Server support","title":"LibSSH.Demo.print_timeline","text":"print_timeline(ds::LibSSH.Demo.DemoServer)\n\n\nPrint a nicely formatted timeline of callbacks and their logged data. Useful when debugging.\n\n\n\n\n\n","category":"method"},{"location":"server_support/#LibSSH.Demo.start-Tuple{LibSSH.Demo.DemoServer}","page":"Server support","title":"LibSSH.Demo.start","text":"start(demo_server::LibSSH.Demo.DemoServer)\n\n\nStart a DemoServer, which means bind to a port and start the ssh.listen loop.\n\n\n\n\n\n","category":"method"},{"location":"server_support/#LibSSH.Demo.stop-Tuple{LibSSH.Demo.DemoServer}","page":"Server support","title":"LibSSH.Demo.stop","text":"stop(demo_server::LibSSH.Demo.DemoServer)\n\n\nStop a DemoServer.\n\n\n\n\n\n","category":"method"},{"location":"sftp/","page":"SFTP","title":"SFTP","text":"CurrentModule = LibSSH","category":"page"},{"location":"sftp/#SFTP","page":"SFTP","title":"SFTP","text":"","category":"section"},{"location":"sftp/","page":"SFTP","title":"SFTP","text":"A subset of the SFTP API is wrapped and available in LibSSH.jl. See the SFTP example for an example of basic usage.","category":"page"},{"location":"sftp/","page":"SFTP","title":"SFTP","text":"warning: Warning\nWhen it comes to handling paths, the library currently assumes that the server is running on a *NIX system. Some functions will not work when connecting to a Windows server.","category":"page"},{"location":"sftp/","page":"SFTP","title":"SFTP","text":"Unlike the rest of the API, the SFTP C functions are blocking and only work with blocking Session's. This means that the library has to lock the session while calling them and no other operations (blocking or unblocking) can occur while they're being called. In practice this restriction may not be too onerous since most calls shouldn't take long anyway, and the read/write implementations use SFTP's asynchronous IO API so they shouldn't block for long. If it's critical that SFTP operations don't interfere with other operations (e.g. port forwarding) a workaround would be to open a separate Session for SFTP.","category":"page"},{"location":"sftp/","page":"SFTP","title":"SFTP","text":"Note that we call all blocking C functions using @threadcall so that they don't block the scheduler, hence as a programmer you don't need to worry about them hogging a whole thread until they complete.","category":"page"},{"location":"sftp/","page":"SFTP","title":"SFTP","text":"Pages = [\"sftp.md\"]\nDepth = 3","category":"page"},{"location":"sftp/#SftpSession","page":"SFTP","title":"SftpSession","text":"","category":"section"},{"location":"sftp/","page":"SFTP","title":"SFTP","text":"SftpSession\nSftpSession(::Session)\nSftpSession(::Function)\nBase.close(::SftpSession)\nBase.isopen(::SftpSession)\nBase.lock(::SftpSession)\nBase.unlock(::SftpSession)\nBase.readdir(::AbstractString, ::SftpSession)\nBase.rm(::AbstractString, ::SftpSession)\nBase.mkdir(::AbstractString, ::SftpSession)\nBase.mv(::AbstractString, ::AbstractString, ::SftpSession)\nBase.stat(::String, ::SftpSession)\nget_extensions(::SftpSession)\nget_limits(::SftpSession)\nget_error(::SftpSession)","category":"page"},{"location":"sftp/#LibSSH.SftpSession","page":"SFTP","title":"LibSSH.SftpSession","text":"mutable struct SftpSession\n\nThis represents a SFTP session, through which one can do SFTP operations. It is only usable while its parent Session is still open, and it must be closed explicitly with Base.close(::SftpSession) or it will leak memory.\n\n\n\n\n\n","category":"type"},{"location":"sftp/#LibSSH.SftpSession-Tuple{LibSSH.Session}","page":"SFTP","title":"LibSSH.SftpSession","text":"SftpSession(session::LibSSH.Session) -> LibSSH.SftpSession\n\n\nCreate a SftpSession from an existing Session.\n\nThrows\n\nArgumentError: If session isn't open.\nLibSSHException: If creating the SFTP session fails.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#LibSSH.SftpSession-Tuple{Function}","page":"SFTP","title":"LibSSH.SftpSession","text":"SftpSession(f::Function, args...; kwargs...) -> Any\n\n\nDo-constructor, the function f will be called like f(sftp) with the new SftpSession.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.close-Tuple{LibSSH.SftpSession}","page":"SFTP","title":"Base.close","text":"close(sftp::LibSSH.SftpSession)\n\n\nClose an SftpSession. This will also close any open files.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.isopen-Tuple{LibSSH.SftpSession}","page":"SFTP","title":"Base.isopen","text":"isopen(sftp::LibSSH.SftpSession) -> Bool\n\n\nCheck if sftp is open.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.lock-Tuple{LibSSH.SftpSession}","page":"SFTP","title":"Base.lock","text":"lock(sftp::LibSSH.SftpSession)\n\n\nLock an SftpSession.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.unlock-Tuple{LibSSH.SftpSession}","page":"SFTP","title":"Base.unlock","text":"unlock(sftp::LibSSH.SftpSession)\n\n\nUnlock an SftpSession.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.readdir-Tuple{AbstractString, LibSSH.SftpSession}","page":"SFTP","title":"Base.Filesystem.readdir","text":"readdir(\n    dir::AbstractString,\n    sftp::LibSSH.SftpSession;\n    only_names,\n    join,\n    sort\n) -> Union{Vector{String}, Vector{LibSSH.SftpAttributes}}\n\n\nRead the contents of a remote directory. By default this will behave the same as Base.readdir() and return a list of names, but if only_names=false it will return a list of SftpAttributes. The join and sort arguments are the same as in Base.readdir() but only apply when only_names=true.\n\nThrows\n\nArgumentError: If sftp is closed.\nSftpException: If retrieving the directory contents failed.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.rm-Tuple{AbstractString, LibSSH.SftpSession}","page":"SFTP","title":"Base.Filesystem.rm","text":"rm(\n    path::AbstractString,\n    sftp::LibSSH.SftpSession;\n    attrs,\n    recursive,\n    force\n)\n\n\nDelete remote file and directories. This has the same behaviour as Base.rm(), and the recursive and force options mean the same thing.\n\nInternally the function will call Base.stat(::String, ::SftpSession) to determine how to delete path, but if you already have the result of that it can be passed to the attrs keyword argument to avoid the extra blocking call.\n\nThrows\n\nArgumentError: If sftp is closed.\nBase.IOError: If path is a non-empty directory and recursive=false.\nSftpException if deletion fails for some reason.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.mkdir-Tuple{AbstractString, LibSSH.SftpSession}","page":"SFTP","title":"Base.Filesystem.mkdir","text":"mkdir(\n    path::AbstractString,\n    sftp::LibSSH.SftpSession;\n    mode\n) -> AbstractString\n\n\nMake a remote directory. This behaves in exactly the same way as Base.mkdir().\n\nThrows\n\nArgumentError: If sftp is closed.\nSftpException: If making the directory fails.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.mv-Tuple{AbstractString, AbstractString, LibSSH.SftpSession}","page":"SFTP","title":"Base.Filesystem.mv","text":"mv(\n    src::AbstractString,\n    dst::AbstractString,\n    sftp::LibSSH.SftpSession;\n    force\n) -> AbstractString\n\n\nMove src to dst remotely. Has the same behaviour as Base.mv().\n\nThrows\n\nArgumentError: If sftp is closed.\nSftpException: If the operation fails for some reason.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.stat-Tuple{String, LibSSH.SftpSession}","page":"SFTP","title":"Base.stat","text":"stat(\n    path::String,\n    sftp::LibSSH.SftpSession\n) -> LibSSH.SftpAttributes\n\n\nGet information about the file object at path as a SftpAttributes.\n\nNote: the Demo.DemoServer does not support setting all of these properties.\n\nThrows\n\nArgumentError: If sftp is closed.\nSftpException: If retrieving the file object information failed (e.g. if the path doesn't exist).\n\n\n\n\n\n","category":"method"},{"location":"sftp/#LibSSH.get_extensions-Tuple{LibSSH.SftpSession}","page":"SFTP","title":"LibSSH.get_extensions","text":"get_extensions(\n    sftp::LibSSH.SftpSession\n) -> Dict{String, String}\n\n\nGet a list of supported server extensions and their versions.\n\nThrows\n\nArgumentError: If sftp is closed.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#LibSSH.get_limits-Tuple{LibSSH.SftpSession}","page":"SFTP","title":"LibSSH.get_limits","text":"get_limits(\n    sftp::LibSSH.SftpSession\n) -> LibSSH.lib.sftp_limits_struct\n\n\nGet the server limits. The returned object has the following fields:\n\nmax_packet_length\nmax_read_length\nmax_write_length\nmax_open_handles\n\nThrows\n\nArgumentError: If sftp is closed.\nSftpException: If getting the limits failed.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#LibSSH.get_error-Tuple{LibSSH.SftpSession}","page":"SFTP","title":"LibSSH.get_error","text":"get_error(sftp::LibSSH.SftpSession) -> LibSSH.SftpError\n\n\nGet the current error code for sftp.\n\nThrows\n\nArgumentError: If sftp is closed.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#SftpFile","page":"SFTP","title":"SftpFile","text":"","category":"section"},{"location":"sftp/","page":"SFTP","title":"SFTP","text":"SftpFile\nBase.open(::String, ::SftpSession)\nBase.open(::Function, ::String, ::SftpSession)\nBase.close(::SftpFile)\nBase.read(::SftpFile)\nBase.read(::String, ::SftpSession)\nBase.read(::SftpFile, ::Type{String})\nBase.read(::String, ::SftpSession, ::Type{String})\nBase.read!(::SftpFile, ::Vector{UInt8})\nBase.write(::SftpFile, ::DenseVector)\nBase.write(::SftpFile, ::AbstractString)\n\nBase.isopen(::SftpFile)\nBase.isreadable(::SftpFile)\nBase.isreadonly(::SftpFile)\nBase.iswritable(::SftpFile)\nBase.position(::SftpFile)\nBase.seek(::SftpFile, ::Integer)\nBase.seekstart(::SftpFile)\nBase.seekend(::SftpFile)","category":"page"},{"location":"sftp/#LibSSH.SftpFile","page":"SFTP","title":"LibSSH.SftpFile","text":"mutable struct SftpFile\n\nptr::Union{Nothing, Ptr{LibSSH.lib.sftp_file_struct}}\nsftp::LibSSH.SftpSession\npath::String\nfullpath::String\nflags::@NamedTuple{read::Bool, write::Bool, create::Bool, truncate::Bool, append::Bool, exclusive::Bool}\n\nRepresents a remote file. This object must be explicitly closed with close() or it will leak memory. Don't create one of these yourself, use Base.open(::String, ::SftpSession).\n\n\n\n\n\n","category":"type"},{"location":"sftp/#Base.open-Tuple{String, LibSSH.SftpSession}","page":"SFTP","title":"Base.open","text":"open(\n    path::String,\n    sftp::LibSSH.SftpSession;\n    read,\n    write,\n    create,\n    truncate,\n    append,\n    exclusive,\n    mode\n) -> LibSSH.SftpFile\n\n\nOpen a remote file. Most of the keyword arguments behave in exactly the same way as their counterparts in Base.open(::String), except for exclusive and mode, which are unique to this method:\n\nexclusive: Open a file with the O_EXCL flag.\nmode: If create=true and the file doesn't exist, it will be created with permissions (mode & ~umask).\n\nThrows\n\nArgumentError: If sftp is closed.\nSftpException: If opening the file fails.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.open-Tuple{Function, String, LibSSH.SftpSession}","page":"SFTP","title":"Base.open","text":"open(\n    f::Function,\n    path::String,\n    sftp::LibSSH.SftpSession;\n    kwargs...\n) -> Any\n\n\nDo-constructor for SftpFile's, the function f will be called like f(file).\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.close-Tuple{LibSSH.SftpFile}","page":"SFTP","title":"Base.close","text":"close(file::LibSSH.SftpFile)\n\n\nClose file. This must be called explicitly, and not in a finalizer because it may cause a task switch.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.read-Tuple{LibSSH.SftpFile}","page":"SFTP","title":"Base.read","text":"read(file::LibSSH.SftpFile) -> Vector{UInt8}\nread(file::LibSSH.SftpFile, nb::Integer) -> Vector{UInt8}\n\n\nRead at most nb bytes from the remote SftpFile. Uses Base.read!(::SftpFile, ::Vector{UInt8}) internally.\n\nThrows\n\nArgumentError: If file is closed.\nSftpException: If reading failed.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.read-Tuple{String, LibSSH.SftpSession}","page":"SFTP","title":"Base.read","text":"read(\n    filename::AbstractString,\n    sftp::LibSSH.SftpSession\n) -> Vector{UInt8}\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.read-Tuple{LibSSH.SftpFile, Type{String}}","page":"SFTP","title":"Base.read","text":"read(file::LibSSH.SftpFile, _::Type{String}) -> String\n\n\nRead the whole file as a String.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.read-Tuple{String, LibSSH.SftpSession, Type{String}}","page":"SFTP","title":"Base.read","text":"read(\n    filename::AbstractString,\n    sftp::LibSSH.SftpSession,\n    _::Type{String}\n) -> String\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.read!-Tuple{LibSSH.SftpFile, Vector{UInt8}}","page":"SFTP","title":"Base.read!","text":"read!(\n    file::LibSSH.SftpFile,\n    out::Vector{UInt8}\n) -> Vector{UInt8}\n\n\nRead length(out) bytes from the remote SftpFile into out. This uses libssh's asynchronous IO functions under the hood so it may launch multiple parallel requests.\n\nThrows\n\nArgumentError: If file is closed.\nSftpException: If reading failed.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.write-Tuple{LibSSH.SftpFile, DenseVector}","page":"SFTP","title":"Base.write","text":"write(file::LibSSH.SftpFile, data::DenseVector) -> Any\n\n\nWrite data to the remote file and returns the number of bytes written. This uses libssh's asynchronous IO API so it may launch multiple parallel requests.\n\nThrows\n\nArgumentError: If file is closed.\nSftpException: If writing fails.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.write-Tuple{LibSSH.SftpFile, AbstractString}","page":"SFTP","title":"Base.write","text":"write(file::LibSSH.SftpFile, data::AbstractString) -> Any\n\n\nWrite a string directly to file. Uses Base.write(::SftpFile, ::DenseVector) internally.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.isopen-Tuple{LibSSH.SftpFile}","page":"SFTP","title":"Base.isopen","text":"isopen(file::LibSSH.SftpFile) -> Bool\n\n\nCheck if file is open.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.isreadable-Tuple{LibSSH.SftpFile}","page":"SFTP","title":"Base.isreadable","text":"isreadable(file::LibSSH.SftpFile) -> Bool\n\n\nCheck if file is open and readable.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.isreadonly-Tuple{LibSSH.SftpFile}","page":"SFTP","title":"Base.isreadonly","text":"isreadonly(file::LibSSH.SftpFile) -> Bool\n\n\nCheck if file is open and readonly.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.iswritable-Tuple{LibSSH.SftpFile}","page":"SFTP","title":"Base.iswritable","text":"iswritable(file::LibSSH.SftpFile) -> Bool\n\n\nCheck if file is open and writable.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.position-Tuple{LibSSH.SftpFile}","page":"SFTP","title":"Base.position","text":"position(file::LibSSH.SftpFile) -> UInt64\n\n\nGet the current position in file.\n\nThrows\n\nArgumentError: If file is closed.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.seek-Tuple{LibSSH.SftpFile, Integer}","page":"SFTP","title":"Base.seek","text":"seek(file::LibSSH.SftpFile, pos::Integer)\n\n\nGo to position pos in file. Note that this will not validate pos.\n\nThrows\n\nArgumentError: If file is closed.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.seekstart-Tuple{LibSSH.SftpFile}","page":"SFTP","title":"Base.seekstart","text":"seekstart(file::LibSSH.SftpFile)\n\n\nGo to the beginning of file.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.seekend-Tuple{LibSSH.SftpFile}","page":"SFTP","title":"Base.seekend","text":"seekend(file::LibSSH.SftpFile)\n\n\nGo to the end of file.\n\n\n\n\n\n","category":"method"},{"location":"sftp/#File-type-helpers","page":"SFTP","title":"File type helpers","text":"","category":"section"},{"location":"sftp/","page":"SFTP","title":"SFTP","text":"Base.ispath(::AbstractString, ::SftpSession)\nBase.ispath(::SftpAttributes)\nBase.isdir(::AbstractString, ::SftpSession)\nBase.isdir(::SftpAttributes)\nBase.isfile(::AbstractString, ::SftpSession)\nBase.isfile(::SftpAttributes)\nBase.issocket(::AbstractString, ::SftpSession)\nBase.issocket(::SftpAttributes)\nBase.islink(::AbstractString, ::SftpSession)\nBase.islink(::SftpAttributes)\nBase.isblockdev(::AbstractString, ::SftpSession)\nBase.isblockdev(::SftpAttributes)\nBase.ischardev(::AbstractString, ::SftpSession)\nBase.ischardev(::SftpAttributes)\nBase.isfifo(::AbstractString, ::SftpSession)\nBase.isfifo(::SftpAttributes)","category":"page"},{"location":"sftp/#Base.Filesystem.ispath-Tuple{AbstractString, LibSSH.SftpSession}","page":"SFTP","title":"Base.Filesystem.ispath","text":"ispath(\n    path::AbstractString,\n    sftp::LibSSH.SftpSession\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.ispath-Tuple{LibSSH.SftpAttributes}","page":"SFTP","title":"Base.Filesystem.ispath","text":"ispath(_::LibSSH.SftpAttributes) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.isdir-Tuple{AbstractString, LibSSH.SftpSession}","page":"SFTP","title":"Base.Filesystem.isdir","text":"isdir(\n    path::AbstractString,\n    sftp::LibSSH.SftpSession\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.isdir-Tuple{LibSSH.SftpAttributes}","page":"SFTP","title":"Base.Filesystem.isdir","text":"isdir(attrs::LibSSH.SftpAttributes) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.isfile-Tuple{AbstractString, LibSSH.SftpSession}","page":"SFTP","title":"Base.Filesystem.isfile","text":"isfile(\n    path::AbstractString,\n    sftp::LibSSH.SftpSession\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.isfile-Tuple{LibSSH.SftpAttributes}","page":"SFTP","title":"Base.Filesystem.isfile","text":"isfile(attrs::LibSSH.SftpAttributes) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.issocket-Tuple{AbstractString, LibSSH.SftpSession}","page":"SFTP","title":"Base.Filesystem.issocket","text":"issocket(\n    path::AbstractString,\n    sftp::LibSSH.SftpSession\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.issocket-Tuple{LibSSH.SftpAttributes}","page":"SFTP","title":"Base.Filesystem.issocket","text":"issocket(attrs::LibSSH.SftpAttributes) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.islink-Tuple{AbstractString, LibSSH.SftpSession}","page":"SFTP","title":"Base.Filesystem.islink","text":"islink(\n    path::AbstractString,\n    sftp::LibSSH.SftpSession\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.islink-Tuple{LibSSH.SftpAttributes}","page":"SFTP","title":"Base.Filesystem.islink","text":"islink(attrs::LibSSH.SftpAttributes) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.isblockdev-Tuple{AbstractString, LibSSH.SftpSession}","page":"SFTP","title":"Base.Filesystem.isblockdev","text":"isblockdev(\n    path::AbstractString,\n    sftp::LibSSH.SftpSession\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.isblockdev-Tuple{LibSSH.SftpAttributes}","page":"SFTP","title":"Base.Filesystem.isblockdev","text":"isblockdev(attrs::LibSSH.SftpAttributes) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.ischardev-Tuple{AbstractString, LibSSH.SftpSession}","page":"SFTP","title":"Base.Filesystem.ischardev","text":"ischardev(\n    path::AbstractString,\n    sftp::LibSSH.SftpSession\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.ischardev-Tuple{LibSSH.SftpAttributes}","page":"SFTP","title":"Base.Filesystem.ischardev","text":"ischardev(attrs::LibSSH.SftpAttributes) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.isfifo-Tuple{AbstractString, LibSSH.SftpSession}","page":"SFTP","title":"Base.Filesystem.isfifo","text":"isfifo(\n    path::AbstractString,\n    sftp::LibSSH.SftpSession\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Base.Filesystem.isfifo-Tuple{LibSSH.SftpAttributes}","page":"SFTP","title":"Base.Filesystem.isfifo","text":"isfifo(attrs::LibSSH.SftpAttributes) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"sftp/#Other-types","page":"SFTP","title":"Other types","text":"","category":"section"},{"location":"sftp/","page":"SFTP","title":"SFTP","text":"SftpAttributes\nSftpError\nSftpException","category":"page"},{"location":"sftp/#LibSSH.SftpAttributes","page":"SFTP","title":"LibSSH.SftpAttributes","text":"mutable struct SftpAttributes\n\nAttributes of remote file objects. This has the following (read-only) properties:\n\nname::String\nlongname::String\nflags::UInt32\ntype::UInt8\nsize::UInt64\nuid::UInt32\ngid::UInt32\nowner::String\ngroup::String\npermissions::UInt32\natime64::UInt64\natime::UInt32\natime_nseconds::UInt32\ncreatetime::UInt64\ncreatetime_nseconds::UInt32\nmtime64::UInt64\nmtime::UInt32\nmtime_nseconds::UInt32\nacl::String\nextended_count::UInt32\nextended_type::String\nextended_data::String\n\n\n\n\n\n","category":"type"},{"location":"sftp/#LibSSH.SftpError","page":"SFTP","title":"LibSSH.SftpError","text":"primitive type SftpError <: Enum{Int32} 32\n\nEnum for possible SFTP error codes. Note that despite its name, SftpError_Ok does not indicate an error.\n\nSftpError_Ok\nSftpError_Eof\nSftpError_NoSuchFile\nSftpError_PermissionDenied\nSftpError_GenericFailure\nSftpError_BadMessage\nSftpError_NoConnection\nSftpError_ConnectionLost\nSftpError_OpUnsupported\nSftpError_InvalidHandle\nSftpError_NoSuchPath\nSftpError_FileAlreadyExists\nSftpError_WriteProtect\nSftpError_NoMedia\n\n\n\n\n\n","category":"type"},{"location":"sftp/#LibSSH.SftpException","page":"SFTP","title":"LibSSH.SftpException","text":"struct SftpException <: Exception\n\nmsg::String\npath::Union{Nothing, String}\nerror_code::LibSSH.SftpError\nsession_error::String\nsession_userhost::String\n\nRepresents an error from the SFTP subsystem.\n\n\n\n\n\n","category":"type"},{"location":"sftp/","page":"SFTP","title":"SFTP","text":"When an SftpException is printed it will be displayed like this:","category":"page"},{"location":"sftp/","page":"SFTP","title":"SFTP","text":"import LibSSH as ssh\nssh.SftpException(\"Failure\", \"/tmp/foo\", ssh.SftpError_GenericFailure, \"SFTP failed\", \"foo@bar\")","category":"page"},{"location":"sftp/","page":"SFTP","title":"SFTP","text":"Note that the SFTP subsystem doesn't always set an error on the Session, so take the Session error with a grain of salt.","category":"page"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"EditURL = \"https://github.com/JuliaWeb/LibSSH.jl/blob/master/CHANGELOG.md\"","category":"page"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"CurrentModule = LibSSH","category":"page"},{"location":"generated_changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"This documents notable changes in LibSSH.jl. The format is based on Keep a Changelog.","category":"page"},{"location":"generated_changelog/#[v0.7.0](https://github.com/JuliaWeb/LibSSH.jl/releases/tag/v0.7.0)-2024-10-25","page":"Changelog","title":"v0.7.0 - 2024-10-25","text":"","category":"section"},{"location":"generated_changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Demo.DemoServer now supports passing allow_auth_none=true to allow easily setting up passwordless authentication (#28).","category":"page"},{"location":"generated_changelog/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Previously the Demo.DemoServer's command execution implementation would only send the command output after it had finished. Now the output gets sent as soon as it's printed by the command (#28).","category":"page"},{"location":"generated_changelog/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Breaking: set_channel_callbacks() will remove any existing callbacks (#28).","category":"page"},{"location":"generated_changelog/#[v0.6.1](https://github.com/JuliaWeb/LibSSH.jl/releases/tag/v0.6.1)-2024-10-20","page":"Changelog","title":"v0.6.1 - 2024-10-20","text":"","category":"section"},{"location":"generated_changelog/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Added support for setting the file descriptor for a Session during construction (#21).\nOur Base.run() methods now accept plain Strings as well as Cmds (#24).\nImplemented convenience Base.read(::String, ::SftpSession) methods that will take a String filename without having to open the file explicitly (#25).\nAdded support for specifying whether a Session should use the users SSH config with the process_config option (#25).","category":"page"},{"location":"generated_changelog/#Fixed-2","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Improved handling of possible errors in Base.readdir() (#20).\nFixed exception handling for Base.run(), now it throws a SshProcessFailedException or LibSSHException on command failure instead of a plain TaskFailedException (#25).","category":"page"},{"location":"generated_changelog/#[v0.6.0](https://github.com/JuliaWeb/LibSSH.jl/releases/tag/v0.6.0)-2024-10-11","page":"Changelog","title":"v0.6.0 - 2024-10-11","text":"","category":"section"},{"location":"generated_changelog/#Added-3","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Implemented Base.readchomp(::Cmd) for remote commands (#12).\nAdd support for passing environment variables to remote commands with Base.run(::Cmd) (#12).\nMade it possible to assign callbacks to Callbacks.ServerCallbacks and Callbacks.ChannelCallbacks by property (#14).\nclose(::SshChannel) and closewrite(::SshChannel) now support an allow_fail argument that will print a warning instead of throw an exception if modifying the lib.ssh_channel fails (#16).\nInitial SFTP client support (#16, #18, #19).","category":"page"},{"location":"generated_changelog/#Fixed-3","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Fixed segfaults that would occur in SshChannel when its Session is disconnected by the remote end (#13).\nFixed some concurrency bugs in the Demo.DemoServer and SessionEvent (#15).\nFixed a race condition in the Demo.DemoServer that could cause segfaults (#16).","category":"page"},{"location":"generated_changelog/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Breaking: Session now needs to be closed explictly instead of relying on the finalizer for the memory to be freed.","category":"page"},{"location":"generated_changelog/#[v0.5.0](https://github.com/JuliaWeb/LibSSH.jl/releases/tag/v0.5.0)-2024-08-10","page":"Changelog","title":"v0.5.0 - 2024-08-10","text":"","category":"section"},{"location":"generated_changelog/#Added-4","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"A new Forwarder(::Session, ::String, ::Int) constructor to allow for forwarding a port to an internal socket instead of to a port (#10).","category":"page"},{"location":"generated_changelog/#Changed-3","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Updated the libssh library to 0.11.0 (#11).","category":"page"},{"location":"generated_changelog/#[v0.4.0](https://github.com/JuliaWeb/LibSSH.jl/releases/tag/v0.4.0)-2024-03-12","page":"Changelog","title":"v0.4.0 - 2024-03-12","text":"","category":"section"},{"location":"generated_changelog/#Added-5","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"A throw argument to poll_loop() (#9).\nSupport for some more options in Session (#9).\nA new method for PKI.get_fingerprint_hash(::PKI.SshKey) to get a public key fingerprint straight from a PKI.SshKey (#9).","category":"page"},{"location":"generated_changelog/#Changed-4","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Some automatically-wrapped low-level functions changed names back to retaining their ssh_ prefixes, and they now have a throw argument to allow disabling throwing an exception upon error (#9).\nauthenticate() will now do host verification as well. This is critical for security so it is strongly recommend that all dependencies update to this release (#9).\nAll the throw_on_* arguments in the various Session and SshChannel methods have been renamed throw for consistency with Base and the new throw arguments in some auto-wrapped bindings (#9).","category":"page"},{"location":"generated_changelog/#[v0.3.0](https://github.com/JuliaWeb/LibSSH.jl/releases/tag/v0.3.0)-2024-03-10","page":"Changelog","title":"v0.3.0 - 2024-03-10","text":"","category":"section"},{"location":"generated_changelog/#Added-6","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"It's possible to set an interface for the Forwarder socket to listen on with the localinterface argument (#6).\nA new Gssapi module to help with GSSAPI support. In particular, Gssapi.principal_name() was added to get the name of the default principal if one is available (#6).\nAn experimental authenticate() function to simplify authenticating (#7).\nA do-constructor for Session(::Function) (#8).","category":"page"},{"location":"generated_changelog/#Changed-5","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"The userauth_* functions will now throw a LibSSHException by default if they got a AuthStatus_Error from libssh. This can be disabled by passing throw_on_error=false (#6).\ngssapi_available() was renamed to Gssapi.isavailable() (#6).\nuserauth_kbdint_getprompts() returns a vector of KbdintPrompt objects instead of tuples (#7).","category":"page"},{"location":"generated_changelog/#Fixed-4","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Fixed some race conditions in poll_loop() and Forwarder() (#6).\nBase.run(::Cmd, ::Session) now properly converts commands into strings before executing them remotely, previously things like quotes weren't escaped properly (#6).\nFixed a bug in Base.run(::Cmd, ::Session) that would clear the output buffer when printing (#6).\nChanged poll_loop() to poll the stdout and stderr streams, which fixes a bug where callbacks would sometimes not get executed even when data was available (#8).","category":"page"},{"location":"generated_changelog/#[v0.2.1](https://github.com/JuliaWeb/LibSSH.jl/releases/tag/v0.2.1)-2024-02-27","page":"Changelog","title":"v0.2.1 - 2024-02-27","text":"","category":"section"},{"location":"generated_changelog/#Added-7","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Initial client support for GSSAPI authentication (#3). This is not fully tested, so use it with caution.","category":"page"},{"location":"generated_changelog/#Changed-6","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Renamed channel_send_eof() to closewrite(::SshChannel) (#4).","category":"page"},{"location":"generated_changelog/#Fixed-5","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"An exception in get_error(::Session) (#5).","category":"page"},{"location":"generated_changelog/#[v0.2.0](https://github.com/JuliaWeb/LibSSH.jl/releases/tag/v0.2.0)-2024-02-01","page":"Changelog","title":"v0.2.0 - 2024-02-01","text":"","category":"section"},{"location":"generated_changelog/#Changed-7","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"The Command execution API was completely rewritten to match Julia's API (#2). This is a breaking change, any code using the old ssh.execute() will need to be rewritten.","category":"page"},{"location":"generated_changelog/#Fixed-6","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"A cause of segfaults was fixed by storing callbacks properly, so they don't get garbage collected accidentally (#2).","category":"page"},{"location":"generated_changelog/#[v0.1.0](https://github.com/JuliaWeb/LibSSH.jl/releases/tag/v0.1.0)-2024-01-29","page":"Changelog","title":"v0.1.0 - 2024-01-29","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"The initial release  ","category":"page"},{"location":"generated_changelog/#Added-8","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"generated_changelog/","page":"Changelog","title":"Changelog","text":"Basic client support, and high-level wrappers for some Channel operations.\nA Demo server for testing SSH clients.","category":"page"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"CurrentModule = LibSSH","category":"page"},{"location":"sessions_and_channels/#Sessions-and-Channels","page":"Sessions and Channels","title":"Sessions and Channels","text":"","category":"section"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"The symbols documented on this page are intended to be safe. They may throw exceptions but they should never cause memory corruptions or segfaults if used correctly.","category":"page"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"This documents the high-level API around SSH sessions and channels, which is almost everything you need to care about to create a SSH client.","category":"page"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"Pages = [\"sessions_and_channels.md\"]\nDepth = 10","category":"page"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"","category":"page"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"AuthMethod\nAuthStatus\nLibSSHException\nKnownHosts\nHostVerificationException","category":"page"},{"location":"sessions_and_channels/#LibSSH.AuthMethod","page":"Sessions and Channels","title":"LibSSH.AuthMethod","text":"primitive type AuthMethod <: Enum{Int32} 32\n\nEnum for the different authentication methods libssh supports:\n\nAuthMethod_Unknown\nAuthMethod_None\nAuthMethod_Password\nAuthMethod_PublicKey\nAuthMethod_HostBased\nAuthMethod_Interactive\nAuthMethod_GSSAPI_MIC\n\n\n\n\n\n","category":"type"},{"location":"sessions_and_channels/#LibSSH.AuthStatus","page":"Sessions and Channels","title":"LibSSH.AuthStatus","text":"primitive type AuthStatus <: Enum{Int32} 32\n\nEnum for the possible authentication responses from a server:\n\nAuthStatus_Error\nAuthStatus_Denied\nAuthStatus_Partial\nAuthStatus_Success\nAuthStatus_Info\nAuthStatus_Again\n\n\n\n\n\n","category":"type"},{"location":"sessions_and_channels/#LibSSH.lib.LibSSHException","page":"Sessions and Channels","title":"LibSSH.lib.LibSSHException","text":"struct LibSSHException <: Exception\n\nA custom exception type to represent errors from libssh's C API.\n\n\n\n\n\n","category":"type"},{"location":"sessions_and_channels/#LibSSH.KnownHosts","page":"Sessions and Channels","title":"LibSSH.KnownHosts","text":"primitive type KnownHosts <: Enum{Int32} 32\n\nEnum for the result of checking a servers public key in the users known hosts file. See is_known_server().\n\nKnownHosts_Ok\nKnownHosts_Changed\nKnownHosts_Other\nKnownHosts_Unknown\nKnownHosts_NotFound\nKnownHosts_Error\n\n\n\n\n\n","category":"type"},{"location":"sessions_and_channels/#LibSSH.HostVerificationException","page":"Sessions and Channels","title":"LibSSH.HostVerificationException","text":"struct HostVerificationException <: Exception\n\nmsg::String\nstatus::LibSSH.KnownHosts\n\nRepresents a failed host verification. See the status field for the exact reason.\n\n\n\n\n\n","category":"type"},{"location":"sessions_and_channels/#Sessions","page":"Sessions and Channels","title":"Sessions","text":"","category":"section"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"An SSH session represents a connection between a client and a remote server. A session must be authenticated before being able to do anything with it.","category":"page"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"info: Info\nAlso see the upstream tutorial.","category":"page"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"Session\nSession(::Union{AbstractString, Sockets.IPAddr})\nSession(::lib.ssh_session)\nSession(::Function)\nconnect\ndisconnect\nisconnected\nis_known_server\nget_server_publickey\nupdate_known_hosts\nauthenticate\nauthenticate_cli\nuserauth_list\nuserauth_none\nuserauth_password\nuserauth_kbdint\nuserauth_kbdint_getprompts\nuserauth_kbdint_setanswers\nuserauth_gssapi\nget_error(::Session)\nBase.isopen(::Session)\nBase.close(::Session)\nBase.wait(::Session)","category":"page"},{"location":"sessions_and_channels/#LibSSH.Session","page":"Sessions and Channels","title":"LibSSH.Session","text":"mutable struct Session\n\nptr::Union{Nothing, Ptr{LibSSH.lib.ssh_session_struct}}\nowning::Bool\ncloseables::Vector{Any}\nserver_callbacks::Union{Nothing, LibSSH.Callbacks.ServerCallbacks}\nlog_verbosity::Int64\nssh_dir::Union{Nothing, String}\nknown_hosts::Union{Nothing, String}\ngssapi_server_identity::Union{Nothing, String}\nprocess_config::Bool\n_lock::ReentrantLock\n_auth_methods::Union{Nothing, Vector{LibSSH.AuthMethod}}\n_attempted_auth_methods::Vector{LibSSH.AuthMethod}\n_require_init_kbdint::Bool\n_waiter_request::Base.Event\n_wakeup::LibSSH.CloseableCondition\n_waiter_stop_flag::Bool\n_waiter_task::Task\n\nRepresents an SSH session. Note that some properties such as the host and port are implemented in getproperty()/setproperty!() by using the internal values of the ssh_session, i.e. they aren't simply fields of the struct. A Session may be owning or non-owning of its internal pointer to a lib.ssh_session.\n\nIt must be closed explicitly with Base.close(::Session) or it will leak memory.\n\n\n\n\n\n","category":"type"},{"location":"sessions_and_channels/#LibSSH.Session-Tuple{Union{AbstractString, Sockets.IPAddr}}","page":"Sessions and Channels","title":"LibSSH.Session","text":"Session(\n    host::Union{AbstractString, Sockets.IPAddr};\n    ...\n) -> LibSSH.Session\nSession(\n    host::Union{AbstractString, Sockets.IPAddr},\n    port;\n    socket,\n    user,\n    log_verbosity,\n    auto_connect,\n    process_config\n) -> LibSSH.Session\n\n\nConstructor for creating a client session. Use this if you want to connect to a server.\n\nwarning: Warning\nBy default libssh will try to follow the settings in any found SSH config files. If a proxyjump is configured for host libssh will try to set up the proxy itself, which usually does not play well with Julia's event loop. In such situations you will probably want to pass process_config=false and set up the proxyjump explicitly using a Forwarder.\n\nThrows\n\nLibSSHException: if a session couldn't be created, or there was an error initializing the user property.\n\nArguments\n\nhost: The host to connect to.\nport=22: The port to connect to.\nsocket=nothing: Can be an open TCPSocket or RawFD to connect to directly. If this is not nothing it will be used instead of port. You will need to close the socket afterwards, the Session will not do it for you.\nuser=nothing: Set the user to connect as. If unset the current  username will be used.\nlog_verbosity=nothing: Set the log verbosity for the session.\nauto_connect=true: Whether to automatically call connect().\nprocess_config=true: Whether to process any found SSH config files.\n\nExamples\n\njulia> import LibSSH as ssh\njulia> session = ssh.Session(\"foo.org\")\njulia> session = ssh.Session(ip\"12.34.56.78\", 2222)\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#LibSSH.Session-Tuple{Ptr{LibSSH.lib.ssh_session_struct}}","page":"Sessions and Channels","title":"LibSSH.Session","text":"Session(\n    ptr::Ptr{LibSSH.lib.ssh_session_struct};\n    log_verbosity,\n    own\n) -> LibSSH.Session\n\n\nThis is only useful if you already have a ssh_session (i.e. in a server). Do not use it if you want a client, use the host/port constructor.\n\nArguments\n\nptr: A pointer to the lib.ssh_session to wrap.\nlog_verbosity=nothing: Set the log verbosity for the  session. This argument will be ignored if own is false to avoid  accidentally changing the logging level in callbacks when non-owning  Sessions are created. You can still set the logging level explicitly with  session.log_verbosity if necessary.\nown=true: Whether to take ownership of ptr, i.e. whether to register a finalizer to free the memory.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#LibSSH.Session-Tuple{Function}","page":"Sessions and Channels","title":"LibSSH.Session","text":"Session(f::Function, args...; kwargs...) -> Any\n\n\nDo-constructor for Session. All arguments are forwarded to the other constructors.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#LibSSH.connect","page":"Sessions and Channels","title":"LibSSH.connect","text":"connect(session::LibSSH.Session)\n\n\nThis will throw an exception if connecting fails. You shouldn't need this unless you've created a session with Session(; auto_connect=false).\n\nWrapper around lib.ssh_connect().\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.disconnect","page":"Sessions and Channels","title":"LibSSH.disconnect","text":"disconnect(session::LibSSH.Session)\n\n\nWrapper around lib.ssh_disconnect().\n\nwarning: Warning\nThis will close all channels created from the session.\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.isconnected","page":"Sessions and Channels","title":"LibSSH.isconnected","text":"isconnected(session::LibSSH.Session) -> Bool\n\n\nWrapper around lib.ssh_is_connected().\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.is_known_server","page":"Sessions and Channels","title":"LibSSH.is_known_server","text":"is_known_server(\n    session::LibSSH.Session;\n    throw\n) -> LibSSH.KnownHosts\n\n\nCheck if the connected servers public key exists in the SSH known hosts file.\n\nThrows\n\nArgumentError: If the session isn't connected.\nHostVerificationException: If verification failed and throw is true.\n\nArguments\n\nthrow=true: Whether to throw a HostVerificationException if the verification fails, otherwise the function will just return the verification status.\n\nWrapper around lib.ssh_session_is_known_server().\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.get_server_publickey","page":"Sessions and Channels","title":"LibSSH.get_server_publickey","text":"get_server_publickey(\n    session::LibSSH.Session\n) -> LibSSH.PKI.SshKey\n\n\nGet the public key from server of a connected session.\n\nThrows\n\nArgumentError: If the session isn't connected.\nLibSSHException: If there was an internal error.\n\nWrapper around lib.ssh_get_server_publickey().\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.update_known_hosts","page":"Sessions and Channels","title":"LibSSH.update_known_hosts","text":"update_known_hosts(session::LibSSH.Session)\n\n\nUpdate the users known hosts file with the sessions server key.\n\nThrows\n\nArgumentError: If the session isn't connected.\nLibSSHException: If there was an internal error.\n\nWrapper around lib.ssh_session_update_known_hosts().\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.authenticate","page":"Sessions and Channels","title":"LibSSH.authenticate","text":"authenticate(\n    session::LibSSH.Session;\n    password,\n    kbdint_answers,\n    throw\n) -> Union{LibSSH.AuthMethod, LibSSH.AuthStatus, LibSSH.KnownHosts}\n\n\nThis is a helper function that boldly attempts to handle the entire authentication flow by figuring out which authentication methods are still available and calling the appropriate functions for you. It may need to be called multiple times to complete authentication, the idea is that it will only return when user input is needed (e.g. for a password, or to accept a host key, etc).\n\nIt can return any of:\n\nA KnownHosts to indicate that host verification failed in some way. It will not return KnownHosts_Ok.\nA AuthStatus to indicate that authentication finished in some way. The caller doesn't need to do anything else in this case but may retry authenticating. It will not return AuthStatus_Info/AuthStatus_Again/AuthStatus_Partial.\nA AuthMethod to indicate the next method to try. This is only returned for auth methods that require user input (i.e. AuthMethod_Password or AuthMethod_Interactive), and the caller must pass the user input next time they call authenticate().\n\nwarning: Warning\nIf you're using this function do not call any of the other userauth_* functions, except for userauth_kbdint_getprompts() to get the server prompts if necessary. authenticate() maintains some internal state to keep track of where it is in authentication, which can be messed up by calling other auth methods yourself.\n\nwarning: Warning\nauthenticate() is quite experimental, we suggest testing it with authenticate_cli() to verify it works on the servers you're authenticating to.\n\nArguments\n\nsession: The Session to authenticate.\npassword=nothing: A password to authenticate with. Pass this if authenticate() previously returned AuthMethod_Password.\nkbdint_answers=nothing: Answers to keyboard-interactive prompts from the server. Use userauth_kbdint_getprompts() to get the prompts if authenticate() returns AuthMethod_Interactive and then pass the answers in the next call.\nthrow=true: Whether to throw if there's an internal error while authenticating (AuthStatus_Error).\n\nThrows\n\nArgumentError: If the session isn't connected, or if both password and kbdint_answers are passed.\nErrorException: If there are no more supported authentication methods available.\nLibSSHException: If there's an internal error and throw=true.\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.authenticate_cli","page":"Sessions and Channels","title":"LibSSH.authenticate_cli","text":"authenticate_cli(\n    session::LibSSH.Session\n) -> Union{LibSSH.AuthStatus, LibSSH.KnownHosts}\n\n\nMeant to mimic authenticating with the ssh command by calling authenticate() in a loop while prompting the user if necessary. It's useful to use this at the REPL to test whether the server can be authenticated to at all.\n\nExamples\n\njulia> session = ssh.Session(\"test.com\"; user=\"myuser\")\nLibSSH.Session(host=test.com, port=22, user=myuser, connected=true)\n\njulia> ssh.authenticate_cli(session)\nPassword:\n[ Info: AuthStatus_Info\nOne-time password:\n[ Info: AuthStatus_Success\nAuthStatus_Success::AuthStatus = 0\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.userauth_list","page":"Sessions and Channels","title":"LibSSH.userauth_list","text":"userauth_list(\n    session::LibSSH.Session;\n    call_auth_none\n) -> Vector{LibSSH.AuthMethod}\n\n\nGet a list of support authentication methods from the server. This will automatically call userauth_none() beforehand if call_auth_none=true (the default).\n\nThrows\n\nArgumentError: If the session isn't connected.\n\nWrapper around lib.ssh_userauth_list().\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.userauth_none","page":"Sessions and Channels","title":"LibSSH.userauth_none","text":"userauth_none(\n    session::LibSSH.Session;\n    throw\n) -> LibSSH.AuthStatus\n\n\nAttempt to authenticate to the server without any credentials. This authentication method is always disabled in practice, but it's still useful to check which authentication methods the server supports (see userauth_list()).\n\nArguments\n\nsession: The session to authenticate.\nthrow=true: Whether to throw if there's an internal error while authenticating (AuthStatus_Error).\n\nThrows\n\nArgumentError: If the session isn't connected.\nLibSSHException: If there was an internal error, unless throw=false.\n\nWrapper around lib.ssh_userauth_none().\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.userauth_password","page":"Sessions and Channels","title":"LibSSH.userauth_password","text":"userauth_password(\n    session::LibSSH.Session,\n    password::String;\n    throw\n) -> LibSSH.AuthStatus\n\n\nAuthenticate by username and password. The username will be taken from session.user.\n\nArguments\n\nsession: The session to authenticate.\npassword: The password to authenticate with.\nthrow=true: Whether to throw if there's an internal error while authenticating (AuthStatus_Error).\n\nThrows\n\nArgumentError: If the session isn't connected.\nLibSSHException: If there was an internal error, unless throw=false.\n\nWrapper around lib.ssh_userauth_password().\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.userauth_kbdint","page":"Sessions and Channels","title":"LibSSH.userauth_kbdint","text":"userauth_kbdint(\n    session::LibSSH.Session;\n    throw\n) -> LibSSH.AuthStatus\n\n\nAttempt to authenticate with the keyboard-interactive method.\n\nArguments\n\nsession: The session to authenticate.\nthrow=true: Whether to throw if there's an internal error while authenticating (AuthStatus_Error).\n\nThrows\n\nArgumentError: If the session isn't connected.\nLibSSHException: If there was an internal error, unless throw=false.\n\nWrapper around lib.ssh_userauth_kbdint.\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.userauth_kbdint_getprompts","page":"Sessions and Channels","title":"LibSSH.userauth_kbdint_getprompts","text":"userauth_kbdint_getprompts(\n    session::LibSSH.Session\n) -> Vector{LibSSH.KbdintPrompt}\n\n\nReturns all the keyboard-interactive prompts from the server. You should have already called userauth_kbdint(). The KbdintPrompt objects it returns have .msg and .display fields that hold the prompt message and whether to echo the user input (e.g. it will be false for a password and other sensitive input).\n\nThis is a combination of lib.ssh_userauth_kbdint_getnprompts() and lib.ssh_userauth_kbdint_getprompt(). It should be preferred over the lower-level functions.\n\nThrows\n\nArgumentError: If the session isn't connected.\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.userauth_kbdint_setanswers","page":"Sessions and Channels","title":"LibSSH.userauth_kbdint_setanswers","text":"userauth_kbdint_setanswers(\n    session::LibSSH.Session,\n    answers::Vector{String}\n)\n\n\nSets answers for a keyboard-interactive auth session. Uses lib.ssh_userauth_kbdint_setanswer internally.\n\nArguments\n\nsession: The session to authenticate.\nanswers: A vector of answers for each prompt sent by the server.\n\nThrows\n\nArgumentError: If the session isn't connected, or if the wrong number of answers were passed.\nLibSSHException: If setting the answers failed.\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.userauth_gssapi","page":"Sessions and Channels","title":"LibSSH.userauth_gssapi","text":"userauth_gssapi(\n    session::LibSSH.Session;\n    throw\n) -> LibSSH.AuthStatus\n\n\nAuthenticate with GSSAPI. This is not available on all platforms (see Gssapi.isavailable()).\n\nArguments\n\nsession: The session to authenticate.\nthrow=true: Whether to throw if there's an internal error while authenticating (AuthStatus_Error).\n\nThrows\n\nArgumentError: If the session isn't connected.\nErrorException: If GSSAPI support isn't available.\nLibSSHException: If there was an internal error, unless throw=false.\n\nWrapper around lib.ssh_userauth_gssapi().\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.get_error-Tuple{LibSSH.Session}","page":"Sessions and Channels","title":"LibSSH.get_error","text":"get_error(session::LibSSH.Session) -> String\n\n\nGet the last error set by libssh.\n\nThrows\n\nArgumentError: If the session has been closed.\n\nWrapper around lib.ssh_get_error().\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.isopen-Tuple{LibSSH.Session}","page":"Sessions and Channels","title":"Base.isopen","text":"isopen(session::LibSSH.Session) -> Bool\n\n\nCheck if a session is open.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.close-Tuple{LibSSH.Session}","page":"Sessions and Channels","title":"Base.close","text":"close(session::LibSSH.Session)\n\n\nCloses a session, which will be unusable afterwards. It's safe to call this multiple times.\n\nThrows\n\nArgumentError: If the session is non-owning. This is not allowed to prevent accidental double-frees.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.wait-Tuple{LibSSH.Session}","page":"Sessions and Channels","title":"Base.wait","text":"wait(session::LibSSH.Session) -> Any\n\n\nWaits for data to be readable/writable on a session.\n\nThrows\n\nInvalidStateException: If the session is already closed, or is closed while waiting.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Channels","page":"Sessions and Channels","title":"Channels","text":"","category":"section"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"SSH channels are things you can create on top of a session to actually do things (like running commands, etc). You can have as many channels on a single session as you like. Channels have certain types, like an exec channel for running commands, and can only be used to do one thing. e.g. if you want to run two commands you must create two channels.","category":"page"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"info: Info\nThe upstream tutorial has more information about channels.","category":"page"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"SshChannel\nSshChannel(::Session)\nSshChannel(::Function, ::Session)\nSshChannel(::lib.ssh_channel, Any)\n\nCallbacks.ChannelCallbacks\nCallbacks.ChannelCallbacks()\nset_channel_callbacks\nchannel_request_send_exit_status\npoll_loop\n\nBase.isassigned(::SshChannel)\nBase.isopen(::SshChannel)\nBase.close(::SshChannel)\nBase.eof(::SshChannel)\nBase.closewrite(::SshChannel)\nBase.iswritable(::SshChannel)\nBase.write(::SshChannel, ::AbstractString)\nBase.write(::SshChannel, ::Vector{UInt8})","category":"page"},{"location":"sessions_and_channels/#LibSSH.SshChannel","page":"Sessions and Channels","title":"LibSSH.SshChannel","text":"mutable struct SshChannel\n\nptr::Union{Nothing, Ptr{LibSSH.lib.ssh_channel_struct}}\nowning::Bool\nsession::Union{Nothing, LibSSH.Session}\nclose_lock::ReentrantLock\nlocal_eof::Bool\ncallbacks::Union{Nothing, LibSSH.Callbacks.ChannelCallbacks}\n\nWraps a lib.ssh_channel. An SshChannel can be owning or non-owning of a pointer to the underlying lib.ssh_channel, and only owning SshChannels can be closed with close(::SshChannel).\n\nThe type is named SshChannel to avoid confusion with Julia's own Channel type.\n\n\n\n\n\n","category":"type"},{"location":"sessions_and_channels/#LibSSH.SshChannel-Tuple{LibSSH.Session}","page":"Sessions and Channels","title":"LibSSH.SshChannel","text":"SshChannel(session::LibSSH.Session) -> LibSSH.SshChannel\n\n\nCreate a channel from an existing session. Note that creating the channel will fail unless the session is connected and authenticated.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#LibSSH.SshChannel-Tuple{Function, LibSSH.Session}","page":"Sessions and Channels","title":"LibSSH.SshChannel","text":"SshChannel(f::Function, session::LibSSH.Session) -> Any\n\n\nDo-constructor for a SshChannel. This will ensure that the channel is closed after f() completes.\n\nExample:\n\ndata = ssh.SshChannel(session) do sshchan\n    return 42\nend\n@assert data == 42\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#LibSSH.SshChannel-Tuple{Ptr{LibSSH.lib.ssh_channel_struct}, Any}","page":"Sessions and Channels","title":"LibSSH.SshChannel","text":"SshChannel(ptr::Ptr{LibSSH.lib.ssh_channel_struct}; ...)\nSshChannel(\n    ptr::Ptr{LibSSH.lib.ssh_channel_struct},\n    session;\n    own\n) -> LibSSH.SshChannel\n\n\nWrap a SshChannel around an already existing lib.ssh_channel. Don't use this unless you know what you're doing, prefer the SshChannel(::Session) constructor instead.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#LibSSH.Callbacks.ChannelCallbacks","page":"Sessions and Channels","title":"LibSSH.Callbacks.ChannelCallbacks","text":"mutable struct ChannelCallbacks\n\nWrapper around lib.ssh_channel_callbacks_struct.\n\n\n\n\n\n","category":"type"},{"location":"sessions_and_channels/#LibSSH.Callbacks.ChannelCallbacks-Tuple{}","page":"Sessions and Channels","title":"LibSSH.Callbacks.ChannelCallbacks","text":"ChannelCallbacks(; ...) -> LibSSH.Callbacks.ChannelCallbacks\nChannelCallbacks(\n    userdata;\n    on_data,\n    on_eof,\n    on_close,\n    on_signal,\n    on_exit_status,\n    on_exit_signal,\n    on_pty_request,\n    on_shell_request,\n    on_auth_agent_req,\n    on_x11_req,\n    on_pty_window_change,\n    on_exec_request,\n    on_env_request,\n    on_subsystem_request,\n    on_write_wontblock,\n    on_open_response,\n    on_request_response\n) -> LibSSH.Callbacks.ChannelCallbacks\n\n\nCreate a callbacks object to set on a channel. A default function is registered for each callback and it will print a warning if a callback was requested but not found, so you don't need to set all of the callbacks for the channel to work properly. The only exceptions are:\n\non_write_wontblock=Returns(0)\non_open_response=Returns(nothing)\non_request_response=Returns(nothing)\n\nWhich have default callbacks because they're always called but rarely necessary to set explicitly.\n\nThe callback functions should all match the signature f(::Session, ::SshChannel, args..., userdata). Note that some argument types will automatically be converted from the C types:\n\nlib.ssh_session -> a non-owning ssh.Session\nlib.ssh_channel -> a non-owning ssh.SshChannel\nCstring -> String\nCint/Cuint/Cchar -> Int/UInt/Char\n\nThe userdata pointer in the C callback signatures will automatically be converted to its original Julia type. Boolean argments are not yet converted from their Cint types to Bool.\n\nwarning: Warning\nDo not use ssh.Session or ssh.SshChannel arguments outside the callback functions. They are temporary non-owning wrappers, and they will be unusable after the callback has been executed.\n\nArguments\n\nAll of these are also properties that can be set after creation.\n\nuserdata: An arbitrary object that will be passed to each callback  function.\non_data: f(::Session, ::SshChannel, ::Vector{UInt8}, Int, userdata)::Int\non_eof: f(::Session, ::SshChannel, userdata)::Nothing\non_close: f(::Session, ::SshChannel, userdata)::Nothing\non_signal: f(::Session, ::SshChannel, ::String, userdata)::Nothing\non_exit_status: f(::Session, ::SshChannel, ::Int, userdata)::Nothing\non_exit_signal: f(::Session, ::SshChannel, ::String, ::Int, ::String, ::String, userdata)::Nothing\non_pty_request: f(::Session, ::SshChannel, ::String, ::Int, ::Int, ::Int, ::Int, userdata)::Bool\non_shell_request: f(::Session, ::SshChannel, userdata)::Bool\non_auth_agent_req: f(::Session, ::SshChannel, userdata)::Nothing\non_x11_req: f(::Session, ::SshChannel, ::Int, ::String, ::String, ::UInt, userdata)::Nothing\non_pty_window_change: f(::Session, ::SshChannel, ::Int, ::Int, ::Int, ::Int, userdata)::Bool\non_exec_request: f(::Session, ::SshChannel, ::String, userdata)::Bool\non_env_request: f(::Session, ::SshChannel, ::String, ::String, userdata)::Bool\non_subsystem_request: f(::Session, ::SshChannel, ::String, userdata)::Bool\non_write_wontblock: f(::Session, ::SshChannel, ::UInt, userdata)::Int\non_open_response: f(::Session, ::SshChannel, ::Bool, userdata)::Nothing\non_request_response: f(::Session, ::SshChannel, userdata)::Nothing\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#LibSSH.set_channel_callbacks","page":"Sessions and Channels","title":"LibSSH.set_channel_callbacks","text":"set_channel_callbacks(\n    sshchan::LibSSH.SshChannel,\n    callbacks::LibSSH.Callbacks.ChannelCallbacks\n) -> LibSSH.Callbacks.ChannelCallbacks\n\n\nWrapper around lib.ssh_set_channel_callbacks() and lib.ssh_remove_channel_callbacks(). Unlike lib.ssh_set_channel_callbacks() this will replace any existing callbacks.\n\nThrows\n\nLibSSHException: If setting the callbacks failed.\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.channel_request_send_exit_status","page":"Sessions and Channels","title":"LibSSH.channel_request_send_exit_status","text":"channel_request_send_exit_status(\n    sshchan::LibSSH.SshChannel,\n    status::Integer\n)\n\n\nSends an exit status in reponse to an exec request. Wrapper around lib.ssh_channel_request_send_exit_status().\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#LibSSH.poll_loop","page":"Sessions and Channels","title":"LibSSH.poll_loop","text":"poll_loop(\n    sshchan::LibSSH.SshChannel;\n    throw\n) -> Union{Nothing, Int64}\n\n\nPoll a (owning) channel in a loop while it's alive, which will trigger any callbacks. This function should always be called on a channel for it to work properly. It will return:\n\nnothing if the channel was closed during the loop.\nOtherwise the last result from lib.ssh_channel_poll(), which should be checked to see if it's SSH_EOF.\n\nThrows\n\nLibSSHException: If SSH_ERROR is returned and throw=true.\n\nArguments\n\nsshchan: The SshChannel to poll.\nthrow=true: Whether to throw an exception if SSH_ERROR is returned.\n\n\n\n\n\n","category":"function"},{"location":"sessions_and_channels/#Base.isassigned-Tuple{LibSSH.SshChannel}","page":"Sessions and Channels","title":"Base.isassigned","text":"isassigned(sshchan::LibSSH.SshChannel) -> Bool\n\n\nCheck if the channel holds a valid pointer to a lib.ssh_channel.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.isopen-Tuple{LibSSH.SshChannel}","page":"Sessions and Channels","title":"Base.isopen","text":"isopen(sshchan::LibSSH.SshChannel) -> Bool\n\n\nChecks if the channel is open. Wrapper around lib.ssh_channel_is_open().\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.close-Tuple{LibSSH.SshChannel}","page":"Sessions and Channels","title":"Base.close","text":"close(sshchan::LibSSH.SshChannel; allow_fail)\n\n\nCloses the channel, and then frees its memory. To avoid the risk of double-frees, this function may only be called on owning SshChannels. It will hold the close_lock of the channel during execution.\n\nArguments\n\nsshchan: The SshChannel to close.\nallow_fail=false: Whether to throw an exception if the call to lib.ssh_channel_close() fails. In some cases it can fail for valid reasons, such as the socket already having been closed by the other end (this will result in a Socket error: disconnected error).\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.eof-Tuple{LibSSH.SshChannel}","page":"Sessions and Channels","title":"Base.eof","text":"eof(sshchan::LibSSH.SshChannel) -> Bool\n\n\nCheck if an EOF has been sent by the remote end. This does not imply that an EOF has been sent from the local end and thus the channel is not writable (for that, use iswritable(::SshChannel)). Check SshChannel.local_eof to check if an EOF has been sent from the local end.\n\nWrapper around lib.ssh_channel_is_eof().\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.closewrite-Tuple{LibSSH.SshChannel}","page":"Sessions and Channels","title":"Base.closewrite","text":"closewrite(\n    sshchan::LibSSH.SshChannel;\n    allow_fail\n) -> Union{Nothing, Bool}\n\n\nSends an EOF message. Calling this function will trigger any waiting callbacks.\n\nThrows\n\nArgumentError: if the channel is not writable.\n\nWrapper around lib.ssh_channel_send_eof().\n\nArguments\n\nsshchan: The SshChannel to send an EOF on.\nallow_fail=false: Whether to throw an exception if the call to lib.ssh_channel_send_eof() fails. In some cases it can fail for valid reasons, such as the socket already having been closed by the other end (this will result in a Socket error: disconnected error).\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.iswritable-Tuple{LibSSH.SshChannel}","page":"Sessions and Channels","title":"Base.iswritable","text":"iswritable(sshchan::LibSSH.SshChannel) -> Bool\n\n\nCheck if the channel is writable.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.write-Tuple{LibSSH.SshChannel, AbstractString}","page":"Sessions and Channels","title":"Base.write","text":"write(\n    sshchan::LibSSH.SshChannel,\n    data::AbstractString;\n    stderr\n) -> Int64\n\n\nWrite a string to the channel and return the number of code units written.\n\nWrapper around lib.ssh_channel_write()/lib.ssh_channel_write_stderr().\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.write-Tuple{LibSSH.SshChannel, Vector{UInt8}}","page":"Sessions and Channels","title":"Base.write","text":"write(\n    sshchan::LibSSH.SshChannel,\n    data::Vector{UInt8};\n    stderr\n) -> Int64\n\n\nWrite a byte array to the channel and return the number of bytes written (should always match the length of the array, unless there was an error, in which case this will throw an exception).\n\nWrapper around lib.ssh_channel_write()/lib.ssh_channel_write_stderr().\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Channel-operations","page":"Sessions and Channels","title":"Channel operations","text":"","category":"section"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"You should prefer using these instead of more low-level methods, if you can.","category":"page"},{"location":"sessions_and_channels/#Command-execution","page":"Sessions and Channels","title":"Command execution","text":"","category":"section"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"LibSSH.jl attempts to mimic Julia's API for running local commands with run() etc. But some features are not supported and we attempt to document all of the differences.","category":"page"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"SshProcessFailedException\nSshProcess\nBase.wait(::SshProcess)\nBase.success(::SshProcess)\nBase.run(::Union{Cmd, String}, ::Session)\nBase.read(::Union{Cmd, String}, ::Session)\nBase.read(::Union{Cmd, String}, ::Session, ::Type{String})\nBase.readchomp(::Union{Cmd, String}, ::Session)\nBase.success(::Union{Cmd, String}, ::Session)","category":"page"},{"location":"sessions_and_channels/#LibSSH.SshProcessFailedException","page":"Sessions and Channels","title":"LibSSH.SshProcessFailedException","text":"struct SshProcessFailedException <: Exception\n\nprocess::LibSSH.SshProcess\n\nThis is analogous to ProcessFailedException.\n\n\n\n\n\n","category":"type"},{"location":"sessions_and_channels/#LibSSH.SshProcess","page":"Sessions and Channels","title":"LibSSH.SshProcess","text":"mutable struct SshProcess\n\nout::Vector{UInt8}\nerr::Vector{UInt8}\ncmd::Union{Nothing, Cmd, String}\nexitcode::Int64\n_sshchan::Union{Nothing, LibSSH.SshChannel}\n_task::Union{Nothing, Task}\n_verbose::Bool\n\nThis is analogous to Base.Process, it represents a command running over an SSH session. The stdout and stderr output are stored as byte arrays in SshProcess.out and SshProcess.err respectively. They can be converted to strings using e.g. String(copy(process.out)).\n\n\n\n\n\n","category":"type"},{"location":"sessions_and_channels/#Base.wait-Tuple{LibSSH.SshProcess}","page":"Sessions and Channels","title":"Base.wait","text":"wait(process::LibSSH.SshProcess)\n\n\nThrows\n\nSshProcessFailedException: if ignorestatus() wasn't used.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.success-Tuple{LibSSH.SshProcess}","page":"Sessions and Channels","title":"Base.success","text":"success(process::LibSSH.SshProcess) -> Bool\n\n\nCheck if the process succeeded.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.run-Tuple{Union{Cmd, String}, LibSSH.Session}","page":"Sessions and Channels","title":"Base.run","text":"run(\n    cmd::Union{Cmd, String},\n    session::LibSSH.Session;\n    wait,\n    verbose,\n    combine_outputs,\n    print_out\n) -> LibSSH.SshProcess\n\n\nRun a command on the remote host over an SSH session. Things that aren't supported compared to run():\n\nPipelined commands (use a regular pipe like foo | bar instead).\nSetting the directory to execute the command in.\n\nAn easy way of getting around these restrictions is to pass the command as a String instead of Cmd.\n\nnote: Note\nSetting environment variables is supported, but will fail if the server forbids setting them.\n\nThrows\n\nSshProcessFailedException: if the command fails and ignorestatus() wasn't used.\nLibSSHException: if running the command fails for some other reason.\n\nArguments\n\ncmd: The command to run. This will be converted to a string for running remotely.\nsession: The session to run the command over.\nwait=true: Wait for the command to finish before returning.\nverbose=false: Print debug logging messages. Note that this is not the same as setting the log_verbosity on a Session.\ncombine_outputs=true: Write the stderr command output to the IOBuffer for the commands stdout. If this is true then SshProcess.out and SshProcess.err will refer to the same object.\nprint_out=true: Print the output (stdout + stderr by default) of the command.\n\nExamples\n\njulia> import LibSSH as ssh\n\njulia> ssh.Demo.DemoServer(2222; password=\"foo\") do\n           session = ssh.Session(\"127.0.0.1\", 2222)\n           @assert ssh.userauth_password(session, \"foo\") == ssh.AuthStatus_Success\n\n           @info \"1\"\n           run(`echo foo`, session)\n\n           println()\n           @info \"2\"\n           run(ignorestatus(`foo`), session)\n\n           println()\n           @info \"3\"\n           # Pass a string to avoid hacking around Cmd syntax\n           run(\"cd /tmp && pwd\", session)\n       end\n[ Info: 1\nfoo\n\n[ Info: 2\nsh: line 1: foo: command not found\n\n[ Info: 3\n/tmp\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.read-Tuple{Union{Cmd, String}, LibSSH.Session}","page":"Sessions and Channels","title":"Base.read","text":"read(\n    cmd::Union{Cmd, String},\n    session::LibSSH.Session\n) -> Vector{UInt8}\n\n\nRead the output from the command in bytes.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.read-Tuple{Union{Cmd, String}, LibSSH.Session, Type{String}}","page":"Sessions and Channels","title":"Base.read","text":"read(\n    cmd::Union{Cmd, String},\n    session::LibSSH.Session,\n    _::Type{String}\n) -> String\n\n\nRead the output from the command as a String.\n\nExamples\n\njulia> import LibSSH as ssh\n\njulia> ssh.Demo.DemoServer(2222; password=\"foo\") do\n           session = ssh.Session(\"127.0.0.1\", 2222)\n           @assert ssh.userauth_password(session, \"foo\") == ssh.AuthStatus_Success\n\n           @show read(`echo foo`, session, String)\n       end\nread(`echo foo`, session, String) = \"foo\\n\"\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.readchomp-Tuple{Union{Cmd, String}, LibSSH.Session}","page":"Sessions and Channels","title":"Base.readchomp","text":"readchomp(\n    cmd::Union{Cmd, String},\n    session::LibSSH.Session\n) -> SubString{String}\n\n\nreadchomp() for remote commands.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.success-Tuple{Union{Cmd, String}, LibSSH.Session}","page":"Sessions and Channels","title":"Base.success","text":"success(\n    cmd::Union{Cmd, String},\n    session::LibSSH.Session\n) -> Bool\n\n\nCheck the command succeeded.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Direct-port-forwarding","page":"Sessions and Channels","title":"Direct port forwarding","text":"","category":"section"},{"location":"sessions_and_channels/","page":"Sessions and Channels","title":"Sessions and Channels","text":"Forwarder\nForwarder(::Session, ::Int, ::String, ::Int)\nForwarder(::Session, ::String, ::Int)\nForwarder(::Function)\nBase.close(::Forwarder)","category":"page"},{"location":"sessions_and_channels/#LibSSH.Forwarder","page":"Sessions and Channels","title":"LibSSH.Forwarder","text":"mutable struct Forwarder\n\nremotehost::String\nremoteport::Int64\nlocalinterface::Sockets.IPAddr\nlocalport::Int64\nout::Union{Nothing, Sockets.TCPSocket}\n_listen_server::Sockets.TCPServer\n_listener_task::Union{Nothing, Task}\n_clients::Vector{LibSSH._ForwardingClient}\n_next_client_id::Int64\n_session::LibSSH.Session\nverbose::Bool\n\nThis object manages a direct forwarding channel between localport and remotehost:remoteport. Fields beginning with an underscore _ are private and should not be used.\n\n\n\n\n\n","category":"type"},{"location":"sessions_and_channels/#LibSSH.Forwarder-Tuple{LibSSH.Session, Int64, String, Int64}","page":"Sessions and Channels","title":"LibSSH.Forwarder","text":"Forwarder(\n    session::LibSSH.Session,\n    localport::Int64,\n    remotehost::String,\n    remoteport::Int64;\n    verbose,\n    localinterface\n) -> LibSSH.Forwarder\n\n\nCreate a Forwarder object to forward data from localport to remotehost:remoteport. This will handle an internal SshChannel for forwarding.\n\nArguments\n\nsession: The session to create a forwarding channel over.\nlocalport: The local port to bind to.\nremotehost: The remote host.\nremoteport: The remote port to bind to.\nverbose: Print logging messages on callbacks etc (not equivalent to setting log_verbosity on a Session).\nlocalinterface=IPv4(0): The interface to bind localport on.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#LibSSH.Forwarder-Tuple{LibSSH.Session, String, Int64}","page":"Sessions and Channels","title":"LibSSH.Forwarder","text":"Forwarder(\n    session::LibSSH.Session,\n    remotehost::String,\n    remoteport::Int64;\n    verbose\n) -> LibSSH.Forwarder\n\n\nCreate a Forwarder object that will forward its data to a single TCPSocket. This is useful if there is only one client and binding to a port available to other processes is not desirable. The socket will be stored in the Forwarder.out property, and it will be closed when the Forwarder is closed.\n\nAll arguments mean the same as in Forwarder(::Session, ::Int, ::String, ::Int).\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#LibSSH.Forwarder-Tuple{Function}","page":"Sessions and Channels","title":"LibSSH.Forwarder","text":"Forwarder(f::Function, args...; kwargs...) -> Any\n\n\nDo-constructor for a Forwarder. All arguments are forwarded to the other constructors.\n\n\n\n\n\n","category":"method"},{"location":"sessions_and_channels/#Base.close-Tuple{LibSSH.Forwarder}","page":"Sessions and Channels","title":"Base.close","text":"close(forwarder::LibSSH.Forwarder)\n\n\nClose a Forwarder. This will close all client channels and the listening local socket.\n\n\n\n\n\n","category":"method"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Libssh is a fairly large project and most of the API still doesn't have high-level wrappers in LibSSH.jl. For example:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Reverse port forwarding\nUnix socket forwarding\nComplete SFTP/SCP support","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you'd like to contribute new wrappers, the usual workflow is:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Add support for the feature in the Demo server and test it with the ssh client from OpenSSH.\nAdd client support for the feature and test it with the newly updated demo server.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This way we can test as much of the codebase as possible.","category":"page"},{"location":"contributing/#Running-tests","page":"Contributing","title":"Running tests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The tests can be run with ] test as usual, but you can also run them more interactively with ReTest.jl and TestEnv.jl:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"julia> using TestEnv; TestEnv.activate(); includet(\"test/LibSSHTests.jl\")\njulia> LibSSHTests.runtests()","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This is particularly helpful when developing since ReTest.jl allows filtering of specific testsets to execute.","category":"page"},{"location":"contributing/#Writing-documentation","page":"Contributing","title":"Writing documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Here's a suggested workflow if you're writing documentation:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"pkg> activate docs\njulia> using LiveServer\n# Note that we ignore automatically generated files, otherwise we'd end up in an\n# infinite loop.\njulia> servedocs(; include_dirs=[\"src\"], skip_files=[\"docs/src/examples.md\", \"docs/src/generated_changelog.md\"])","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This will start a server with LiveServer.jl to automatically rebuild the docs when they're changed. But if you've done something like changed a docstring and only want to build it once, this will work too:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"pkg> activate docs\njulia> include(\"docs/make.jl\")","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Note that the examples are generated automatically from docs/src/examples.jl.","category":"page"},{"location":"contributing/#Updating-the-bindings","page":"Contributing","title":"Updating the bindings","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If there's a new upstream release of libssh, here's how to update everything:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Update the build_tarballs.jl script to build the new version, and submit a PR to Yggdrasil to update libssh_jll. When testing it's often useful to deploy it locally first:\n$ julia --project=@project-with-binary-builder build_tarballs.jl --deploy=local\nUpdate the generated bindings:\npkg> activate gen\njulia> include(\"gen/gen.jl\")\nIf you've build and deployed libssh_jll locally make sure to pkg> dev libssh_jll first, or ] up if the JLL has already been updated in Yggdrasil.\nRun the tests to make sure everything works, then bump the LibSSH.jl version number and release \\o/","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"EditURL = \"examples.jl\"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"CurrentModule = LibSSH","category":"page"},{"location":"examples/#Connecting-and-authenticating","page":"Examples","title":"Connecting and authenticating","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"First we'll import the LibSSH package:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import LibSSH as ssh","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Sadly there aren't many publicly available SSH servers out there so we'll start our own Demo server locally with a Very Secure password:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import LibSSH.Demo as demo\n\ndemo_server = demo.DemoServer(2222; password=\"foo\", auth_methods=[ssh.AuthMethod_Password])\ndemo.start(demo_server)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is just to have something to play with. Now we can create a Session to connect to the server:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"session = ssh.Session(\"127.0.0.1\", 2222)\n@assert ssh.isconnected(session)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And we have a connection! That means that the key exchange between us and the server has finished and we can communicate securely. But we still don't know that the server is who it says it is so the next step is authentication of the server, which means checking its host key. The easiest way to do this is by checking the server key against the users known hosts file:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ssh.is_known_server(session; throw=false)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"KnownHosts_Unknown::KnownHosts = 0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Ok, we got back a KnownHosts_Unknown response. That's because the demo server automatically creates a dummy key to use, and that definitely won't be in the known hosts file. If host verification fails a good client should prompt the user with the key fingerprint and ask them what to do. We can get the key from the session, hash it, and compute a fingerprint:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import LibSSH.PKI as pki\n\nhost_key = ssh.get_server_publickey(session)\nsha256_hash = pki.get_publickey_hash(host_key)\nfingerprint = pki.get_fingerprint_hash(sha256_hash)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\"SHA256:H2ads0nAUOFAY2g8RjsOQVutHOK4WbGUWLnh4CSpJ+w\"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Or convert it to a hex string with get_hexa():","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"hex = ssh.get_hexa(sha256_hash)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\"1f:66:9d:b3:49:c0:50:e1:40:63:68:3c:46:3b:0e:41:5b:ad:1c:e2:b8:59:b1:94:58:b9:e1:e0:24:a9:27:ec\"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Since this is a dummy key from the demo server we don't really want to add it to our known hosts file, but if this was asked to the user and they said yes, it should be added to the known hosts using update_known_hosts(). But since it's a dummy key let's just trust it and continue with authenticating ourselves to the server.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"danger: Danger\nDon't skip host verification. It's the only part of the protocol that libssh doesn't handle for you, and security cannot be guaranteed without it.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Since we created the server we already know that it supports password authentication, but a good client should check anyway:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ssh.userauth_list(session)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"1-element Vector{LibSSH.AuthMethod}:\n AuthMethod_Password::AuthMethod = 2","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If we give the wrong password we'll get denied:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"@assert ssh.userauth_password(session, \"quux\") == ssh.AuthStatus_Denied","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"But the right password should succeed:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"@assert ssh.userauth_password(session, \"foo\") == ssh.AuthStatus_Success","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Going through all the authentication methods can be quite complicated, in practice it may be easier to use authenticate() which will handle all of that for you.","category":"page"},{"location":"examples/#Running-commands","page":"Examples","title":"Running commands","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now that we're authenticated to the server we can actually do something, like running a command (see Command execution):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"@assert read(`echo 'Hello world!'`, session, String) == \"Hello world!\\n\"","category":"page"},{"location":"examples/#SFTP","page":"Examples","title":"SFTP","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"LibSSH.jl allows reading and writing remote files with the same API as local files with Base. Lets start by making a temporary directory and creating a file in it 'remotely':","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"tmpdir = mktempdir()\npath = joinpath(tmpdir, \"foo\")\n\nsftp = ssh.SftpSession(session)\nfile = open(path, sftp; write=true)\nwrite(file, \"foo\") # this returns the number of bytes written","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"3","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can read the file 'remotely':","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"open(path, sftp) do readonly_file\n    read(readonly_file, String)\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\"foo\"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And do other IO-related things:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"seekstart(file)\nposition(file)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"0x0000000000000000","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"isreadable(file)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"false","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"iswritable(file)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"true","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"After using it we have to close it explicitly because the finalizer won't do it for us (see the Base.close(::SftpFile) docstring for details):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"close(file)","category":"page"},{"location":"examples/#Disconnecting","page":"Examples","title":"Disconnecting","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we can disconnect our client session:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"close(sftp)\nclose(session)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And stop the server:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"demo.stop(demo_server)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":" Warning: Closing SshChannel failed with -1: 'Socket error: disconnected'\n @ LibSSH ~/work/LibSSH.jl/LibSSH.jl/src/channel.jl:195\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that sometimes the DemoServer will display a warning that closing an SshChannel failed because of Socket error: disconnected. That can be safely ignored, it just means that the socket was closed on the client side before the server could close the SshChannel, but the SshChannel memory will still be freed. It typically happens when doing SFTP operations since the SftpSession manages its own lib.ssh_channel.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This page was generated using Literate.jl.","category":"page"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"CurrentModule = LibSSH","category":"page"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"This documents notable changes in LibSSH.jl. The format is based on Keep a Changelog.","category":"page"},{"location":"changelog/#[v0.7.0]-2024-10-25","page":"Changelog","title":"[v0.7.0] - 2024-10-25","text":"","category":"section"},{"location":"changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Demo.DemoServer now supports passing allow_auth_none=true to allow easily setting up passwordless authentication ([#28]).","category":"page"},{"location":"changelog/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Previously the Demo.DemoServer's command execution implementation would only send the command output after it had finished. Now the output gets sent as soon as it's printed by the command ([#28]).","category":"page"},{"location":"changelog/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Breaking: set_channel_callbacks() will remove any existing callbacks ([#28]).","category":"page"},{"location":"changelog/#[v0.6.1]-2024-10-20","page":"Changelog","title":"[v0.6.1] - 2024-10-20","text":"","category":"section"},{"location":"changelog/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Added support for setting the file descriptor for a Session during construction ([#21]).\nOur Base.run() methods now accept plain Strings as well as Cmds ([#24]).\nImplemented convenience Base.read(::String, ::SftpSession) methods that will take a String filename without having to open the file explicitly ([#25]).\nAdded support for specifying whether a Session should use the users SSH config with the process_config option ([#25]).","category":"page"},{"location":"changelog/#Fixed-2","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Improved handling of possible errors in Base.readdir() ([#20]).\nFixed exception handling for Base.run(), now it throws a SshProcessFailedException or LibSSHException on command failure instead of a plain TaskFailedException ([#25]).","category":"page"},{"location":"changelog/#[v0.6.0]-2024-10-11","page":"Changelog","title":"[v0.6.0] - 2024-10-11","text":"","category":"section"},{"location":"changelog/#Added-3","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Implemented Base.readchomp(::Cmd) for remote commands ([#12]).\nAdd support for passing environment variables to remote commands with Base.run(::Cmd) ([#12]).\nMade it possible to assign callbacks to Callbacks.ServerCallbacks and Callbacks.ChannelCallbacks by property ([#14]).\nclose(::SshChannel) and closewrite(::SshChannel) now support an allow_fail argument that will print a warning instead of throw an exception if modifying the lib.ssh_channel fails ([#16]).\nInitial SFTP client support ([#16], [#18], [#19]).","category":"page"},{"location":"changelog/#Fixed-3","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Fixed segfaults that would occur in SshChannel when its Session is disconnected by the remote end ([#13]).\nFixed some concurrency bugs in the Demo.DemoServer and SessionEvent ([#15]).\nFixed a race condition in the Demo.DemoServer that could cause segfaults ([#16]).","category":"page"},{"location":"changelog/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Breaking: Session now needs to be closed explictly instead of relying on the finalizer for the memory to be freed.","category":"page"},{"location":"changelog/#[v0.5.0]-2024-08-10","page":"Changelog","title":"[v0.5.0] - 2024-08-10","text":"","category":"section"},{"location":"changelog/#Added-4","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"A new Forwarder(::Session, ::String, ::Int) constructor to allow for forwarding a port to an internal socket instead of to a port ([#10]).","category":"page"},{"location":"changelog/#Changed-3","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Updated the libssh library to 0.11.0 ([#11]).","category":"page"},{"location":"changelog/#[v0.4.0]-2024-03-12","page":"Changelog","title":"[v0.4.0] - 2024-03-12","text":"","category":"section"},{"location":"changelog/#Added-5","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"A throw argument to poll_loop() ([#9]).\nSupport for some more options in Session ([#9]).\nA new method for PKI.get_fingerprint_hash(::PKI.SshKey) to get a public key fingerprint straight from a PKI.SshKey ([#9]).","category":"page"},{"location":"changelog/#Changed-4","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Some automatically-wrapped low-level functions changed names back to retaining their ssh_ prefixes, and they now have a throw argument to allow disabling throwing an exception upon error ([#9]).\nauthenticate() will now do host verification as well. This is critical for security so it is strongly recommend that all dependencies update to this release ([#9]).\nAll the throw_on_* arguments in the various Session and SshChannel methods have been renamed throw for consistency with Base and the new throw arguments in some auto-wrapped bindings ([#9]).","category":"page"},{"location":"changelog/#[v0.3.0]-2024-03-10","page":"Changelog","title":"[v0.3.0] - 2024-03-10","text":"","category":"section"},{"location":"changelog/#Added-6","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"It's possible to set an interface for the Forwarder socket to listen on with the localinterface argument ([#6]).\nA new Gssapi module to help with GSSAPI support. In particular, Gssapi.principal_name() was added to get the name of the default principal if one is available ([#6]).\nAn experimental authenticate() function to simplify authenticating ([#7]).\nA do-constructor for Session(::Function) ([#8]).","category":"page"},{"location":"changelog/#Changed-5","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The userauth_* functions will now throw a LibSSHException by default if they got a AuthStatus_Error from libssh. This can be disabled by passing throw_on_error=false ([#6]).\ngssapi_available() was renamed to Gssapi.isavailable() ([#6]).\nuserauth_kbdint_getprompts() returns a vector of KbdintPrompt objects instead of tuples ([#7]).","category":"page"},{"location":"changelog/#Fixed-4","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Fixed some race conditions in poll_loop() and Forwarder() ([#6]).\nBase.run(::Cmd, ::Session) now properly converts commands into strings before executing them remotely, previously things like quotes weren't escaped properly ([#6]).\nFixed a bug in Base.run(::Cmd, ::Session) that would clear the output buffer when printing ([#6]).\nChanged poll_loop() to poll the stdout and stderr streams, which fixes a bug where callbacks would sometimes not get executed even when data was available ([#8]).","category":"page"},{"location":"changelog/#[v0.2.1]-2024-02-27","page":"Changelog","title":"[v0.2.1] - 2024-02-27","text":"","category":"section"},{"location":"changelog/#Added-7","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Initial client support for GSSAPI authentication ([#3]). This is not fully tested, so use it with caution.","category":"page"},{"location":"changelog/#Changed-6","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Renamed channel_send_eof() to closewrite(::SshChannel) ([#4]).","category":"page"},{"location":"changelog/#Fixed-5","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"An exception in get_error(::Session) ([#5]).","category":"page"},{"location":"changelog/#[v0.2.0]-2024-02-01","page":"Changelog","title":"[v0.2.0] - 2024-02-01","text":"","category":"section"},{"location":"changelog/#Changed-7","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The Command execution API was completely rewritten to match Julia's API ([#2]). This is a breaking change, any code using the old ssh.execute() will need to be rewritten.","category":"page"},{"location":"changelog/#Fixed-6","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"A cause of segfaults was fixed by storing callbacks properly, so they don't get garbage collected accidentally ([#2]).","category":"page"},{"location":"changelog/#[v0.1.0]-2024-01-29","page":"Changelog","title":"[v0.1.0] - 2024-01-29","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The initial release  ","category":"page"},{"location":"changelog/#Added-8","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Basic client support, and high-level wrappers for some Channel operations.\nA Demo server for testing SSH clients.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"CurrentModule = LibSSH","category":"page"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"The symbols documented on this page are intended to be safe. They may throw exceptions but they should never cause memory corruptions or segfaults if used correctly.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"This documents the various other parts of the libssh API that aren't strictly connected to client or server support.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Pages = [\"utilities.md\"]\nDepth = 10","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"lib_version\nget_hexa","category":"page"},{"location":"utilities/#LibSSH.lib_version","page":"Utilities","title":"LibSSH.lib_version","text":"lib_version() -> VersionNumber\n\n\nGet the version of the libssh library that's used.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#LibSSH.get_hexa","page":"Utilities","title":"LibSSH.get_hexa","text":"get_hexa(buffer::Vector{UInt8}) -> String\n\n\nConvert a buffer to a colon-separated hex string. This is identical to bytes2hex(), except that each byte will be separated by a colon.\n\nWrapper around lib.ssh_get_hexa().\n\nExamples\n\njulia> import LibSSH as ssh\n\njulia> buffer = collect(UInt8, 1:10);\n\njulia> ssh.get_hexa(buffer)\n\"01:02:03:04:05:06:07:08:09:0a\"\n\njulia> bytes2hex(buffer)\n\"0102030405060708090a\"\n\n\n\n\n\n","category":"function"},{"location":"utilities/#GSSAPI-support","page":"Utilities","title":"GSSAPI support","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Gssapi.isavailable\nGssapi.principal_name","category":"page"},{"location":"utilities/#LibSSH.Gssapi.isavailable","page":"Utilities","title":"LibSSH.Gssapi.isavailable","text":"isavailable() -> Bool\n\n\nCheck if GSSAPI support is available. Currently this is only available on Linux and FreeBSD because it's difficult to cross-compile Kerberos_krb5_jll for other platforms (which is what we depend on for GSSAPI).\n\n\n\n\n\n","category":"function"},{"location":"utilities/#LibSSH.Gssapi.principal_name","page":"Utilities","title":"LibSSH.Gssapi.principal_name","text":"principal_name() -> Union{Nothing, String}\n\n\nReturns the name of the default principal from the default credential cache, or nothing if a principal with a valid ticket was not found. This can be used to check if ssh.userauth_gssapi() can be called. Under the hood it uses:\n\nkrb5_cc_default()\nkrb5_cc_get_principal()\n\nThrows\n\nErrorException: If GSSAPI support is not available on the current platform (see isavailable()).\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Messages","page":"Utilities","title":"Messages","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"message_type\nmessage_subtype\nmessage_auth_interactive_request","category":"page"},{"location":"utilities/#LibSSH.message_type","page":"Utilities","title":"LibSSH.message_type","text":"message_type(\n    message::Ptr{LibSSH.lib.ssh_message_struct}\n) -> LibSSH.RequestType\n\n\nGet the type of a message. Wrapper around lib.ssh_message_type().\n\n\n\n\n\n","category":"function"},{"location":"utilities/#LibSSH.message_subtype","page":"Utilities","title":"LibSSH.message_subtype","text":"message_subtype(\n    message::Ptr{LibSSH.lib.ssh_message_struct}\n) -> Int32\n\n\nGet the subtype of a message. Wrapper around lib.ssh_message_subtype().\n\n\n\n\n\n","category":"function"},{"location":"utilities/#LibSSH.message_auth_interactive_request","page":"Utilities","title":"LibSSH.message_auth_interactive_request","text":"message_auth_interactive_request(\n    msg::Ptr{LibSSH.lib.ssh_message_struct},\n    name::AbstractString,\n    instruction::AbstractString,\n    prompts::Vector{String},\n    echo::Vector{Bool}\n) -> Int32\n\n\nThis is useful when writing a server, it will specify the requirements for keyboard-interactive authentication to the client.\n\nParameters\n\nmsg: The message to reply to.\nname: The name of the message block.\ninstruction: The instruction for the user.\nprompts: The prompts to show to the user.\necho: Whether the client should echo the answer to the prompts (e.g. it probably shouldn't echo the password).\n\nWrapper around lib.ssh_message_auth_interactive_request().\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PKI","page":"Utilities","title":"PKI","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [LibSSH.PKI]","category":"page"},{"location":"utilities/#LibSSH.PKI.HashType","page":"Utilities","title":"LibSSH.PKI.HashType","text":"primitive type HashType <: Enum{Int32} 32\n\nEnum for possible hash types to use to hash a public key:\n\nHashType_Sha1\nHashType_Md5\nHashType_Sha256\n\n\n\n\n\n","category":"type"},{"location":"utilities/#LibSSH.PKI.KeyCmp","page":"Utilities","title":"LibSSH.PKI.KeyCmp","text":"primitive type KeyCmp <: Enum{Int32} 32\n\nEnum for ways to compare keys:\n\nKeyCmp_Public\nKeyCmp_Private\n\n\n\n\n\n","category":"type"},{"location":"utilities/#LibSSH.PKI.KeyType","page":"Utilities","title":"LibSSH.PKI.KeyType","text":"primitive type KeyType <: Enum{Int32} 32\n\nEnum for the types of keys that are supported:\n\nKeyType_unknown\nKeyType_dss\nKeyType_rsa\nKeyType_rsa1\nKeyType_ecdsa\nKeyType_ed25519\nKeyType_dss_cert01\nKeyType_rsa_cert01\nKeyType_ecdsa_p256\nKeyType_ecdsa_p384\nKeyType_ecdsa_p521\nKeyType_ecdsa_p256_cert01\nKeyType_ecdsa_p384_cert01\nKeyType_ecdsa_p521_cert01\nKeyType_ed25519_cert01\nKeyType_sk_ecdsa\nKeyType_sk_ecdsa_cert01\nKeyType_sk_ed25519\nKeyType_sk_ed25519_cert01\n\n\n\n\n\n","category":"type"},{"location":"utilities/#LibSSH.PKI.SshKey","page":"Utilities","title":"LibSSH.PKI.SshKey","text":"mutable struct SshKey\n\nptr::Union{Nothing, Ptr{LibSSH.lib.ssh_key_struct}}\nowning::Bool\n\nUse PKI.generate to create a key rather than calling the constructors. A SshKey can be owning or non-owning of its pointer to the lib.ssh_key.\n\nwarning: Warning\nAdding a SshKey to a ssh.Bind will cause the key to be free'd when the ssh.Bind is closed! Never use a SshKey after its server has been closed, or make sure it hasn't been free'd by checking isassigned(::SshKey).\n\n\n\n\n\n","category":"type"},{"location":"utilities/#Base.isassigned-Tuple{LibSSH.PKI.SshKey}","page":"Utilities","title":"Base.isassigned","text":"isassigned(key::LibSSH.PKI.SshKey) -> Bool\n\n\nCheck if the SshKey holds a valid pointer to a lib.ssh_key.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#LibSSH.PKI.generate-Tuple{LibSSH.PKI.KeyType}","page":"Utilities","title":"LibSSH.PKI.generate","text":"generate(\n    ktype::LibSSH.PKI.KeyType;\n    bits\n) -> LibSSH.PKI.SshKey\n\n\nWrapper around lib.ssh_pki_generate(). Note that bits=2048 by default.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#LibSSH.PKI.get_fingerprint_hash-Tuple{LibSSH.PKI.SshKey}","page":"Utilities","title":"LibSSH.PKI.get_fingerprint_hash","text":"get_fingerprint_hash(key::LibSSH.PKI.SshKey) -> String\n\n\nGet a fingerprint straight from a SshKey.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#LibSSH.PKI.get_fingerprint_hash-Tuple{Vector{UInt8}}","page":"Utilities","title":"LibSSH.PKI.get_fingerprint_hash","text":"get_fingerprint_hash(hash_buffer::Vector{UInt8}) -> String\n\n\nGet a fingerprint of a public key from a hash. This will automatically guess the kind of hash that was used from the length of hash_buffer.\n\nWrapper around lib.ssh_get_fingerprint_hash().\n\nExamples\n\njulia> import LibSSH.PKI as pki\njulia> key = pki.generate(pki.KeyType_ed25519)\njulia> sha256_hash = pki.get_publickey_hash(key)\njulia> pki.get_fingerprint_hash(sha256_hash)\n\"SHA256:5muLWD4Cl6FYh5ZRr/DYKvmb5r+kJUZQXLuc6ocVRH0\"\n\n\n\n\n\n","category":"method"},{"location":"utilities/#LibSSH.PKI.get_publickey_hash","page":"Utilities","title":"LibSSH.PKI.get_publickey_hash","text":"get_publickey_hash(key::LibSSH.PKI.SshKey) -> Vector{UInt8}\nget_publickey_hash(\n    key::LibSSH.PKI.SshKey,\n    hash_type::LibSSH.PKI.HashType\n) -> Vector{UInt8}\n\n\nGet the hash of the public key of a SshKey (SHA256 by default).\n\nWrapper around lib.ssh_get_publickey_hash().\n\n\n\n\n\n","category":"function"},{"location":"utilities/#LibSSH.PKI.key_cmp-Tuple{LibSSH.PKI.SshKey, LibSSH.PKI.SshKey, LibSSH.PKI.KeyCmp}","page":"Utilities","title":"LibSSH.PKI.key_cmp","text":"key_cmp(\n    key1::LibSSH.PKI.SshKey,\n    key2::LibSSH.PKI.SshKey,\n    part::LibSSH.PKI.KeyCmp\n) -> Bool\n\n\nCompare parts of an SSH key. Wrapper around lib.ssh_key_cmp().\n\n\n\n\n\n","category":"method"},{"location":"utilities/#LibSSH.PKI.key_type-Tuple{LibSSH.PKI.SshKey}","page":"Utilities","title":"LibSSH.PKI.key_type","text":"key_type(key::LibSSH.PKI.SshKey) -> LibSSH.PKI.KeyType\n\n\nWrapper around lib.ssh_key_type().\n\n\n\n\n\n","category":"method"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"CurrentModule = LibSSH","category":"page"},{"location":"#LibSSH.jl","page":"LibSSH.jl","title":"LibSSH.jl","text":"","category":"section"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"This package provides a high-level API and low-level bindings to libssh. You can use it to programmatically create an SSH connection to a remote server and do things like:","category":"page"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"Execute remote commands\nSet up port forwarding\nCreate security holes (better be careful lol)","category":"page"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"The upstream libssh library has implementations for both a client and server, but this package (currently) only attempts to provide a high-level client API. A demo SSH server is available, but it's only intended to be used for tests.","category":"page"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"These docs were generated against this upstream libssh version:","category":"page"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"import LibSSH as ssh\nssh.lib_version()","category":"page"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"warning: Warning\nLibSSH.jl is still under heavy development and may contain bugs. We strongly recommend testing your code as much as possible. If you have found a bug, please report it.","category":"page"},{"location":"#Installation","page":"LibSSH.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"LibSSH.jl is available in the general registry:","category":"page"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"pkg> add LibSSH","category":"page"},{"location":"#Limitations","page":"LibSSH.jl","title":"Limitations","text":"","category":"section"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"GSSAPI support isn't available on all platforms (see Gssapi.isavailable).\nMany features don't have high-level wrappers (see Contributing).","category":"page"},{"location":"#FAQ","page":"LibSSH.jl","title":"FAQ","text":"","category":"section"},{"location":"#Can-I-use-this-to-create-an-SSH-server?","page":"LibSSH.jl","title":"Can I use this to create an SSH server?","text":"","category":"section"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"Technically yes, but you almost certainly shouldn't because authentication and authorization is proper hard and there's lots of ways it could go wrong.","category":"page"},{"location":"#Can-I-use-this-to-create-an-SSH-client?","page":"LibSSH.jl","title":"Can I use this to create an SSH client?","text":"","category":"section"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"Yes. But make sure you test it appropriately with the Demo server.","category":"page"},{"location":"#Why-isn't-beloved-feature-supported-in-the-high-level-API?","page":"LibSSH.jl","title":"Why isn't <beloved-feature> supported in the high-level API?","text":"","category":"section"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"The author is fabulously lazy and hasn't bothered (but will accept PRs to do so <3).","category":"page"},{"location":"#Contents","page":"LibSSH.jl","title":"Contents","text":"","category":"section"},{"location":"","page":"LibSSH.jl","title":"LibSSH.jl","text":"Pages = [\"examples.md\", \"sessions_and_channels.md\", \"sftp.md\", \"server_support.md\", \"utilities.md\", \"bindings.md\"]\nDepth = 10","category":"page"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"CollapsedDocStrings = true","category":"page"},{"location":"bindings/#Low-level-bindings","page":"Low-level bindings","title":"Low-level bindings","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"The symbols documented on this page have all been generated automatically, along with their documentation. Most of them are pure wrappers around the C functions, but some of them also do things like return-type conversion to a Julia type (e.g. converting const char* to String).","category":"page"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Where possible the original documentation from the libssh headers has been included or a link generated to the upstream documentation. Note that some links may not work if the upstream documentation and this page have been generated against different versions, and some symbols in the Other section should be elsewhere.","category":"page"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"warning: Warning\nThe symbols on this page, including the auto-generated wrappers, are unsafe. Improper use may cause memory corruption (including segfaults) and weeping and gnashing of teeth. Check the upstream documentation carefully when using them, and test your code thoroughly.","category":"page"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"","category":"page"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"GLOBAL\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_finalize-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_finalize","text":"ssh_finalize()\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_init-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_init","text":"ssh_init()\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.SSH_AGAIN","page":"Low-level bindings","title":"LibSSH.lib.SSH_AGAIN","text":"Value returned when the function is in non-blocking mode and must be called again.\n\n\n\n\n\n","category":"constant"},{"location":"bindings/#LibSSH.lib.SSH_AUTH_METHOD_GSSAPI_MIC","page":"Low-level bindings","title":"LibSSH.lib.SSH_AUTH_METHOD_GSSAPI_MIC","text":"Auth method enum (upstream documentation).\n\n\n\n\n\n","category":"constant"},{"location":"bindings/#LibSSH.lib.SSH_AUTH_METHOD_HOSTBASED","page":"Low-level bindings","title":"LibSSH.lib.SSH_AUTH_METHOD_HOSTBASED","text":"Auth method enum (upstream documentation).\n\n\n\n\n\n","category":"constant"},{"location":"bindings/#LibSSH.lib.SSH_AUTH_METHOD_INTERACTIVE","page":"Low-level bindings","title":"LibSSH.lib.SSH_AUTH_METHOD_INTERACTIVE","text":"Auth method enum (upstream documentation).\n\n\n\n\n\n","category":"constant"},{"location":"bindings/#LibSSH.lib.SSH_AUTH_METHOD_NONE","page":"Low-level bindings","title":"LibSSH.lib.SSH_AUTH_METHOD_NONE","text":"Auth method enum (upstream documentation).\n\n\n\n\n\n","category":"constant"},{"location":"bindings/#LibSSH.lib.SSH_AUTH_METHOD_PASSWORD","page":"Low-level bindings","title":"LibSSH.lib.SSH_AUTH_METHOD_PASSWORD","text":"Auth method enum (upstream documentation).\n\n\n\n\n\n","category":"constant"},{"location":"bindings/#LibSSH.lib.SSH_AUTH_METHOD_PUBLICKEY","page":"Low-level bindings","title":"LibSSH.lib.SSH_AUTH_METHOD_PUBLICKEY","text":"Auth method enum (upstream documentation).\n\n\n\n\n\n","category":"constant"},{"location":"bindings/#LibSSH.lib.SSH_AUTH_METHOD_UNKNOWN","page":"Low-level bindings","title":"LibSSH.lib.SSH_AUTH_METHOD_UNKNOWN","text":"Auth method enum (upstream documentation).\n\n\n\n\n\n","category":"constant"},{"location":"bindings/#LibSSH.lib.SSH_ERROR","page":"Low-level bindings","title":"LibSSH.lib.SSH_ERROR","text":"Value returned if an error occurred.\n\n\n\n\n\n","category":"constant"},{"location":"bindings/#LibSSH.lib.SSH_OK","page":"Low-level bindings","title":"LibSSH.lib.SSH_OK","text":"Value returned on success.\n\n\n\n\n\n","category":"constant"},{"location":"bindings/#LibSSH.lib.SSH_PACKET_NOT_USED","page":"Low-level bindings","title":"LibSSH.lib.SSH_PACKET_NOT_USED","text":"Upstream documentation.\n\n\n\n\n\n","category":"constant"},{"location":"bindings/#Authentication","page":"Low-level bindings","title":"Authentication","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"auth\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_set_agent_channel-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_agent_channel","text":"ssh_set_agent_channel(session, channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_agent_socket-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_agent_socket","text":"ssh_set_agent_socket(session, fd)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_agent-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_agent","text":"ssh_userauth_agent(session, username)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_gssapi-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_gssapi","text":"ssh_userauth_gssapi(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_kbdint-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_kbdint","text":"ssh_userauth_kbdint(session, user, submethods)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_kbdint_getanswer-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_kbdint_getanswer","text":"ssh_userauth_kbdint_getanswer(session, i; throw = true)\n\nAuto-generated wrapper around ssh_userauth_kbdint_getanswer().\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_kbdint_getinstruction-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_kbdint_getinstruction","text":"ssh_userauth_kbdint_getinstruction(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_kbdint_getname-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_kbdint_getname","text":"ssh_userauth_kbdint_getname(session; throw = true)\n\nAuto-generated wrapper around ssh_userauth_kbdint_getname().\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_kbdint_getnanswers-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_kbdint_getnanswers","text":"ssh_userauth_kbdint_getnanswers(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_kbdint_getnprompts-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_kbdint_getnprompts","text":"ssh_userauth_kbdint_getnprompts(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_kbdint_getprompt-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_kbdint_getprompt","text":"ssh_userauth_kbdint_getprompt(session, i, echo; throw = true)\n\nAuto-generated wrapper around ssh_userauth_kbdint_getprompt().\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_kbdint_setanswer-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_kbdint_setanswer","text":"ssh_userauth_kbdint_setanswer(session, i, answer)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_list-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_list","text":"ssh_userauth_list(session, username)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_none-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_none","text":"ssh_userauth_none(session, username)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_password-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_password","text":"ssh_userauth_password(session, username, password)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_publickey-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_publickey","text":"ssh_userauth_publickey(session, username, privkey)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_publickey_auto-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_publickey_auto","text":"ssh_userauth_publickey_auto(session, username, passphrase)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_publickey_auto_get_current_identity-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_publickey_auto_get_current_identity","text":"ssh_userauth_publickey_auto_get_current_identity(session, value)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_userauth_try_publickey-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_userauth_try_publickey","text":"ssh_userauth_try_publickey(session, username, pubkey)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Buffers","page":"Low-level bindings","title":"Buffers","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"buffer\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_buffer_add_data-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_buffer_add_data","text":"ssh_buffer_add_data(buffer, data, len)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_buffer_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_buffer_free","text":"ssh_buffer_free(buffer)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_buffer_get-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_buffer_get","text":"ssh_buffer_get(buffer)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_buffer_get_data-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_buffer_get_data","text":"ssh_buffer_get_data(buffer, data, requestedlen)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_buffer_get_len-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_buffer_get_len","text":"ssh_buffer_get_len(buffer)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_buffer_new-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_buffer_new","text":"ssh_buffer_new()\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_buffer_reinit-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_buffer_reinit","text":"ssh_buffer_reinit(buffer)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Callbacks","page":"Low-level bindings","title":"Callbacks","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"callbacks\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_add_channel_callbacks-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_add_channel_callbacks","text":"ssh_add_channel_callbacks(channel, cb)\n\nAdd channel callback functions\n\nThis function will add channel callback functions to the channel callback list. Callbacks missing from a callback structure will be probed in the next on the list.\n\nArguments\n\nchannel: The channel to set the callback structure.\ncb: The callback structure itself.\n\nReturns\n\nSSH_OK on success, SSH_ERROR on error.\n\nSee also\n\nssh_set_channel_callbacks\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_remove_channel_callbacks-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_remove_channel_callbacks","text":"ssh_remove_channel_callbacks(channel, cb)\n\nRemove a channel callback.\n\nThe channel has been added with ssh_add_channel_callbacks or ssh_set_channel_callbacks in this case.\n\nArguments\n\nchannel: The channel to remove the callback structure from.\ncb: The callback structure to remove\n\nReturns\n\nSSH_OK on success, SSH_ERROR on error.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_callbacks-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_callbacks","text":"ssh_set_callbacks(session, cb)\n\nSet the session callback functions.\n\nThis functions sets the callback structure to use your own callback functions for auth, logging and status.\n\nNote, that the callback structure is not copied into the session so it needs to be valid for the whole session lifetime.\n\n struct ssh_callbacks_struct cb = {\n   .userdata = data,\n   .auth_function = my_auth_function\n };\n ssh_callbacks_init(&cb);\n ssh_set_callbacks(session, &cb);\n\nArguments\n\nsession: The session to set the callback structure.\ncb: The callback structure itself.\n\nReturns\n\nSSH_OK on success, SSH_ERROR on error.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_channel_callbacks-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_channel_callbacks","text":"ssh_set_channel_callbacks(channel, cb)\n\nSet the channel callback functions.\n\nThis functions sets the callback structure to use your own callback functions for channel data and exceptions.\n\nNote, that the structure is not copied to the channel structure so it needs to be valid as for the whole life of the channel or until it is removed with ssh_remove_channel_callbacks().\n\n struct ssh_channel_callbacks_struct cb = {\n   .userdata = data,\n   .channel_data_function = my_channel_data_function\n };\n ssh_callbacks_init(&cb);\n ssh_set_channel_callbacks(channel, &cb);\n\nwarning: Warning\nthis function will not replace existing callbacks but set the new one atop of them.\n\nArguments\n\nchannel: The channel to set the callback structure.\ncb: The callback structure itself.\n\nReturns\n\nSSH_OK on success, SSH_ERROR on error.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_server_callbacks-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_server_callbacks","text":"ssh_set_server_callbacks(session, cb)\n\nSet the session server callback functions.\n\nThis functions sets the callback structure to use your own callback functions for user authentication, new channels and requests.\n\nNote, that the structure is not copied to the session structure so it needs to be valid for the whole session lifetime.\n\n struct ssh_server_callbacks_struct cb = {\n   .userdata = data,\n   .auth_password_function = my_auth_function\n };\n ssh_callbacks_init(&cb);\n ssh_set_server_callbacks(session, &cb);\n\nArguments\n\nsession: The session to set the callback structure.\ncb: The callback structure itself.\n\nReturns\n\nSSH_OK on success, SSH_ERROR on error.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Channel","page":"Low-level bindings","title":"Channel","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"channel\")","category":"page"},{"location":"bindings/#LibSSH.lib.channel_read_buffer-NTuple{4, Any}","page":"Low-level bindings","title":"LibSSH.lib.channel_read_buffer","text":"channel_read_buffer(channel, buffer, count, is_stderr)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_accept_forward-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_accept_forward","text":"ssh_channel_accept_forward(session, timeout_ms, destination_port)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_accept_x11-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_accept_x11","text":"ssh_channel_accept_x11(channel, timeout_ms)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_cancel_forward-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_cancel_forward","text":"ssh_channel_cancel_forward(session, address, port)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_change_pty_size-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_change_pty_size","text":"ssh_channel_change_pty_size(channel, cols, rows)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_close-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_close","text":"ssh_channel_close(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_free","text":"ssh_channel_free(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_get_exit_state-NTuple{4, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_get_exit_state","text":"ssh_channel_get_exit_state(channel, pexit_code, pexit_signal, pcore_dumped)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_get_exit_status-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_get_exit_status","text":"ssh_channel_get_exit_status(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_get_session-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_get_session","text":"ssh_channel_get_session(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_is_closed-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_is_closed","text":"ssh_channel_is_closed(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_is_eof-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_is_eof","text":"ssh_channel_is_eof(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_is_open-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_is_open","text":"ssh_channel_is_open(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_listen_forward-NTuple{4, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_listen_forward","text":"ssh_channel_listen_forward(session, address, port, bound_port)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_new-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_new","text":"ssh_channel_new(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_open_auth_agent-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_open_auth_agent","text":"ssh_channel_open_auth_agent(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_open_forward-NTuple{5, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_open_forward","text":"ssh_channel_open_forward(channel, remotehost, remoteport, sourcehost, localport)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_open_forward_port-NTuple{5, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_open_forward_port","text":"ssh_channel_open_forward_port(session, timeout_ms, destination_port, originator, originator_port)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_open_forward_unix-NTuple{4, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_open_forward_unix","text":"ssh_channel_open_forward_unix(channel, remotepath, sourcehost, localport)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_open_reverse_forward-NTuple{5, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_open_reverse_forward","text":"ssh_channel_open_reverse_forward(channel, remotehost, remoteport, sourcehost, localport)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_open_session-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_open_session","text":"ssh_channel_open_session(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_open_x11-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_open_x11","text":"ssh_channel_open_x11(channel, orig_addr, orig_port)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_poll-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_poll","text":"ssh_channel_poll(channel, is_stderr)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_poll_timeout-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_poll_timeout","text":"ssh_channel_poll_timeout(channel, timeout, is_stderr)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_read-NTuple{4, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_read","text":"ssh_channel_read(channel, dest, count, is_stderr)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_read_nonblocking-NTuple{4, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_read_nonblocking","text":"ssh_channel_read_nonblocking(channel, dest, count, is_stderr)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_read_timeout-NTuple{5, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_read_timeout","text":"ssh_channel_read_timeout(channel, dest, count, is_stderr, timeout_ms)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_auth_agent-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_auth_agent","text":"ssh_channel_request_auth_agent(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_env-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_env","text":"ssh_channel_request_env(channel, name, value)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_exec-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_exec","text":"ssh_channel_request_exec(channel, cmd)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_pty-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_pty","text":"ssh_channel_request_pty(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_pty_size_modes-NTuple{6, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_pty_size_modes","text":"ssh_channel_request_pty_size_modes(channel, term, cols, rows, modes, modes_len)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_send_break-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_send_break","text":"ssh_channel_request_send_break(channel, length)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_send_exit_signal-NTuple{5, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_send_exit_signal","text":"ssh_channel_request_send_exit_signal(channel, signum, core, errmsg, lang)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_send_exit_status-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_send_exit_status","text":"ssh_channel_request_send_exit_status(channel, exit_status)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_send_signal-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_send_signal","text":"ssh_channel_request_send_signal(channel, signum)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_sftp-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_sftp","text":"ssh_channel_request_sftp(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_shell-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_shell","text":"ssh_channel_request_shell(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_subsystem-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_subsystem","text":"ssh_channel_request_subsystem(channel, subsystem)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_x11-NTuple{5, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_x11","text":"ssh_channel_request_x11(channel, single_connection, protocol, cookie, screen_number)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_select-NTuple{4, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_select","text":"ssh_channel_select(readchans, writechans, exceptchans, timeout)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_send_eof-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_send_eof","text":"ssh_channel_send_eof(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_set_blocking-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_set_blocking","text":"ssh_channel_set_blocking(channel, blocking)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_set_counter-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_set_counter","text":"ssh_channel_set_counter(channel, counter)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_window_size-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_window_size","text":"ssh_channel_window_size(channel)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_write-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_write","text":"ssh_channel_write(channel, data, len)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_channel_write_stderr-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_write_stderr","text":"ssh_channel_write_stderr(channel, data, len)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Errors","page":"Low-level bindings","title":"Errors","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"error\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_get_error-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_error","text":"ssh_get_error(error)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_error_code-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_error_code","text":"ssh_get_error_code(error)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Helpers","page":"Low-level bindings","title":"Helpers","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"misc\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_basename-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_basename","text":"ssh_basename(path)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_dirname-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_dirname","text":"ssh_dirname(path)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_hexa-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_hexa","text":"ssh_get_hexa(what, len)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_random-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_random","text":"ssh_get_random(where, len, strong)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_getpass-NTuple{5, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_getpass","text":"ssh_getpass(prompt, buf, len, echo, verify)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_mkdir-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_mkdir","text":"ssh_mkdir(pathname, mode)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_print_hexa-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_print_hexa","text":"ssh_print_hexa(descr, what, len)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_version-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_version","text":"ssh_version(req_version)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Logging","page":"Low-level bindings","title":"Logging","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"log\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_get_log_callback-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_log_callback","text":"ssh_get_log_callback()\n\nGet the pointer to the logging callback function.\n\nReturns\n\nThe pointer the the callback or NULL if none set.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_log_level-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_log_level","text":"ssh_get_log_level()\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_log_userdata-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_log_userdata","text":"ssh_get_log_userdata()\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_log_callback-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_log_callback","text":"ssh_set_log_callback(cb)\n\nSet the logging callback function.\n\nArguments\n\ncb:[in] The callback to set.\n\nReturns\n\n0 on success, < 0 on error.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_log_level-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_log_level","text":"ssh_set_log_level(level)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_log_userdata-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_log_userdata","text":"ssh_set_log_userdata(data)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Message","page":"Low-level bindings","title":"Message","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"messages\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_message_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_free","text":"ssh_message_free(msg)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_get-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_get","text":"ssh_message_get(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_subtype-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_subtype","text":"ssh_message_subtype(msg)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_type-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_type","text":"ssh_message_type(msg)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Polling","page":"Low-level bindings","title":"Polling","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"poll\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_event_add_connector-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_event_add_connector","text":"ssh_event_add_connector(event, connector)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_event_add_fd-NTuple{5, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_event_add_fd","text":"ssh_event_add_fd(event, fd, events, cb, userdata)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_event_add_session-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_event_add_session","text":"ssh_event_add_session(event, session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_event_dopoll-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_event_dopoll","text":"ssh_event_dopoll(event, timeout)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_event_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_event_free","text":"ssh_event_free(event)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_event_new-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_event_new","text":"ssh_event_new()\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_event_remove_connector-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_event_remove_connector","text":"ssh_event_remove_connector(event, connector)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_event_remove_fd-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_event_remove_fd","text":"ssh_event_remove_fd(event, fd)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_event_remove_session-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_event_remove_session","text":"ssh_event_remove_session(event, session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Public/private-keys","page":"Low-level bindings","title":"Public/private keys","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"pki\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_key_cmp-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_key_cmp","text":"ssh_key_cmp(k1, k2, what)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_key_dup-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_key_dup","text":"ssh_key_dup(key)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_key_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_key_free","text":"ssh_key_free(key)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_key_is_private-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_key_is_private","text":"ssh_key_is_private(k)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_key_is_public-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_key_is_public","text":"ssh_key_is_public(k)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_key_new-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_key_new","text":"ssh_key_new()\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_key_type-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_key_type","text":"ssh_key_type(key)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_key_type_from_name-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_key_type_from_name","text":"ssh_key_type_from_name(name)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_key_type_to_char-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_key_type_to_char","text":"ssh_key_type_to_char(type)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_copy_cert_to_privkey-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_copy_cert_to_privkey","text":"ssh_pki_copy_cert_to_privkey(cert_key, privkey)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_export_privkey_base64-NTuple{5, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_export_privkey_base64","text":"ssh_pki_export_privkey_base64(privkey, passphrase, auth_fn, auth_data, b64_key)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_export_privkey_base64_format-NTuple{6, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_export_privkey_base64_format","text":"ssh_pki_export_privkey_base64_format(privkey, passphrase, auth_fn, auth_data, b64_key, format)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_export_privkey_file-NTuple{5, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_export_privkey_file","text":"ssh_pki_export_privkey_file(privkey, passphrase, auth_fn, auth_data, filename)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_export_privkey_file_format-NTuple{6, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_export_privkey_file_format","text":"ssh_pki_export_privkey_file_format(privkey, passphrase, auth_fn, auth_data, filename, format)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_export_privkey_to_pubkey-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_export_privkey_to_pubkey","text":"ssh_pki_export_privkey_to_pubkey(privkey, pkey)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_export_pubkey_base64-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_export_pubkey_base64","text":"ssh_pki_export_pubkey_base64(key, b64_key)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_export_pubkey_file-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_export_pubkey_file","text":"ssh_pki_export_pubkey_file(key, filename)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_generate-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_generate","text":"ssh_pki_generate(type, parameter, pkey)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_import_cert_base64-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_import_cert_base64","text":"ssh_pki_import_cert_base64(b64_cert, type, pkey)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_import_cert_file-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_import_cert_file","text":"ssh_pki_import_cert_file(filename, pkey)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_import_privkey_base64-NTuple{5, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_import_privkey_base64","text":"ssh_pki_import_privkey_base64(b64_key, passphrase, auth_fn, auth_data, pkey)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_import_privkey_file-NTuple{5, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_import_privkey_file","text":"ssh_pki_import_privkey_file(filename, passphrase, auth_fn, auth_data, pkey)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_import_pubkey_base64-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_import_pubkey_base64","text":"ssh_pki_import_pubkey_base64(b64_key, type, pkey)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_import_pubkey_file-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_import_pubkey_file","text":"ssh_pki_import_pubkey_file(filename, pkey)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_pki_key_ecdsa_name-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_pki_key_ecdsa_name","text":"ssh_pki_key_ecdsa_name(key)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Server","page":"Low-level bindings","title":"Server","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"server\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_bind_accept-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_accept","text":"ssh_bind_accept(ssh_bind_o, session)\n\nAccept an incoming ssh connection and initialize the session.\n\nArguments\n\nssh_bind_o: The ssh server bind to accept a connection.\nsession:\tA preallocated ssh session\n\nReturns\n\nSSH_OK when a connection is established\n\nSee also\n\nssh_new\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_bind_accept_fd-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_accept_fd","text":"ssh_bind_accept_fd(ssh_bind_o, session, fd)\n\nAccept an incoming ssh connection on the given file descriptor and initialize the session.\n\nArguments\n\nssh_bind_o: The ssh server bind to accept a connection.\nsession: A preallocated ssh session\nfd: A file descriptor of an already established TCP inbound connection\n\nReturns\n\nSSH_OK when a connection is established\n\nSee also\n\nssh_new, ssh_bind_accept\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_bind_fd_toaccept-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_fd_toaccept","text":"ssh_bind_fd_toaccept(ssh_bind_o)\n\nAllow the file descriptor to accept new sessions.\n\nArguments\n\nssh_bind_o: The ssh server bind to use.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_bind_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_free","text":"ssh_bind_free(ssh_bind_o)\n\nFree a ssh servers bind.\n\nNote that this will also free options that have been set on the bind, including keys set with SSH_BIND_OPTIONS_IMPORT_KEY.\n\nArguments\n\nssh_bind_o: The ssh server bind to free.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_bind_get_fd-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_get_fd","text":"ssh_bind_get_fd(ssh_bind_o)\n\nRecover the file descriptor from the session.\n\nArguments\n\nssh_bind_o: The ssh server bind to get the fd from.\n\nReturns\n\nThe file descriptor.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_bind_listen-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_listen","text":"ssh_bind_listen(ssh_bind_o)\n\nStart listening to the socket.\n\nArguments\n\nssh_bind_o: The ssh server bind to use.\n\nReturns\n\n0 on success, < 0 on error.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_bind_new-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_new","text":"ssh_bind_new()\n\nCreates a new SSH server bind.\n\nReturns\n\nA newly allocated ssh_bind session pointer.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_bind_options_parse_config-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_options_parse_config","text":"ssh_bind_options_parse_config(sshbind, filename)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_bind_options_set-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_options_set","text":"ssh_bind_options_set(sshbind, type, value)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_bind_set_blocking-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_set_blocking","text":"ssh_bind_set_blocking(ssh_bind_o, blocking)\n\nSet the session to blocking/nonblocking mode.\n\nArguments\n\nssh_bind_o: The ssh server bind to use.\nblocking: Zero for nonblocking mode.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_bind_set_callbacks-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_set_callbacks","text":"ssh_bind_set_callbacks(sshbind, callbacks, userdata)\n\nSet the callback for this bind.\n\n     struct ssh_callbacks_struct cb = {\n         .userdata = data,\n         .auth_function = my_auth_function\n     };\n     ssh_callbacks_init(&cb);\n     ssh_bind_set_callbacks(session, &cb);\n\nArguments\n\nsshbind:[in] The bind to set the callback on.\ncallbacks:[in] An already set up ssh_bind_callbacks instance.\nuserdata:[in] A pointer to private data to pass to the callbacks.\n\nReturns\n\nSSH_OK on success, SSH_ERROR if an error occurred.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_bind_set_fd-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_set_fd","text":"ssh_bind_set_fd(ssh_bind_o, fd)\n\nSet the file descriptor for a session.\n\nArguments\n\nssh_bind_o: The ssh server bind to set the fd.\nfd: The file descriptssh_bind B\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_gssapi_get_creds-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_gssapi_get_creds","text":"ssh_gssapi_get_creds(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_handle_key_exchange-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_handle_key_exchange","text":"ssh_handle_key_exchange(session)\n\nHandles the key exchange and set up encryption\n\nArguments\n\nsession:\tA connected ssh session\n\nReturns\n\nSSH_OK if the key exchange was successful\n\nSee also\n\nssh_bind_accept\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_auth_kbdint_is_response-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_auth_kbdint_is_response","text":"ssh_message_auth_kbdint_is_response(msg)\n\nAuto-generated wrapper around ssh_message_auth_kbdint_is_response().\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_auth_password-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_auth_password","text":"ssh_message_auth_password(msg; throw = true)\n\nAuto-generated wrapper around ssh_message_auth_password(). Original upstream documentation is below.\n\n\n\nGet the password of the authenticated user.\n\ncompat: Deprecated\nThis function should not be used anymore as there is a callback based server implementation now auth_password_function.\n\nArguments\n\nmsg:[in] The message to get the password from.\n\nReturns\n\nThe password or NULL if an error occurred.\n\nSee also\n\nssh_message_get(), ssh_message_type()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_auth_pubkey-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_auth_pubkey","text":"ssh_message_auth_pubkey(msg)\n\nGet the publickey of the authenticated user.\n\nIf you need the key for later user you should duplicate it.\n\ncompat: Deprecated\nThis function should not be used anymore as there is a callback based server implementation auth_pubkey_function.\n\nArguments\n\nmsg:[in] The message to get the public key from.\n\nReturns\n\nThe public key or NULL.\n\nSee also\n\nssh_key_dup(), ssh_key_cmp(), ssh_message_get(), ssh_message_type()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_auth_publickey_state-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_auth_publickey_state","text":"ssh_message_auth_publickey_state(msg)\n\ncompat: Deprecated\nThis function should not be used anymore as there is a callback based server implementation auth_pubkey_function\n\nArguments\n\nmsg:[in] The message to get the public key state from.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_auth_reply_pk_ok-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_auth_reply_pk_ok","text":"ssh_message_auth_reply_pk_ok(msg, algo, pubkey)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_auth_reply_pk_ok_simple-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_auth_reply_pk_ok_simple","text":"ssh_message_auth_reply_pk_ok_simple(msg)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_auth_set_methods-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_auth_set_methods","text":"ssh_message_auth_set_methods(msg, methods; throw = true)\n\nAuto-generated wrapper around ssh_message_auth_set_methods().\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_auth_user-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_auth_user","text":"ssh_message_auth_user(msg; throw = true)\n\nAuto-generated wrapper around ssh_message_auth_user(). Original upstream documentation is below.\n\n\n\nGet the name of the authenticated user.\n\nArguments\n\nmsg:[in] The message to get the username from.\n\nReturns\n\nThe username or NULL if an error occurred.\n\nSee also\n\nssh_message_get(), ssh_message_type()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_global_request_reply_success-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_global_request_reply_success","text":"ssh_message_global_request_reply_success(msg, bound_port)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_reply_default-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_reply_default","text":"ssh_message_reply_default(msg; throw = true)\n\nAuto-generated wrapper around ssh_message_reply_default(). Original upstream documentation is below.\n\n\n\nReply with a standard reject message.\n\nUse this function if you don't know what to respond or if you want to reject a request.\n\nArguments\n\nmsg:[in] The message to use for the reply.\n\nReturns\n\n0 on success, -1 on error.\n\nSee also\n\nssh_message_get()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_service_reply_success-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_service_reply_success","text":"ssh_message_service_reply_success(msg)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_service_service-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_service_service","text":"ssh_message_service_service(msg)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_send_issue_banner-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_send_issue_banner","text":"ssh_send_issue_banner(session, banner)\n\nSend the server's issue-banner to client.\n\nArguments\n\nsession:[in] The server session.\nbanner:[in] The server's banner.\n\nReturns\n\nSSH_OK on success, SSH_ERROR on error.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_send_keepalive-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_send_keepalive","text":"ssh_send_keepalive(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_server_init_kex-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_server_init_kex","text":"ssh_server_init_kex(session)\n\nInitialize the set of key exchange, hostkey, ciphers, MACs, and compression algorithms for the given ssh_session.\n\nThe selection of algorithms and keys used are determined by the options that are currently set in the given ssh_session structure. May only be called before the initial key exchange has begun.\n\nArguments\n\nsession: The session structure to initialize.\n\nReturns\n\nSSH_OK if initialization succeeds.\n\nSee also\n\nssh_handle_key_exchange, ssh_options_set\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_auth_methods-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_auth_methods","text":"ssh_set_auth_methods(session, auth_methods)\n\nSet the acceptable authentication methods to be sent to the client.\n\nSupported methods are:\n\nSSH_AUTH_METHOD_PASSWORD SSH_AUTH_METHOD_PUBLICKEY SSH_AUTH_METHOD_HOSTBASED SSH_AUTH_METHOD_INTERACTIVE SSH_AUTH_METHOD_GSSAPI_MIC\n\nArguments\n\nsession:[in] The server session\nauth_methods:[in] The authentication methods we will support, which can be bitwise-or'd.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_message_callback-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_message_callback","text":"ssh_set_message_callback(session, ssh_bind_message_callback, data)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Session","page":"Low-level bindings","title":"Session","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"session\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_blocking_flush-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_blocking_flush","text":"ssh_blocking_flush(session, timeout)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_clean_pubkey_hash-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_clean_pubkey_hash","text":"ssh_clean_pubkey_hash(hash)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_connect-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_connect","text":"ssh_connect(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_copyright-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_copyright","text":"ssh_copyright()\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_disconnect-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_disconnect","text":"ssh_disconnect(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_dump_knownhost-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_dump_knownhost","text":"ssh_dump_knownhost(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_free","text":"ssh_free(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_cipher_in-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_cipher_in","text":"ssh_get_cipher_in(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_cipher_out-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_cipher_out","text":"ssh_get_cipher_out(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_clientbanner-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_clientbanner","text":"ssh_get_clientbanner(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_disconnect_message-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_disconnect_message","text":"ssh_get_disconnect_message(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_fd-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_fd","text":"ssh_get_fd(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_fingerprint_hash-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_fingerprint_hash","text":"ssh_get_fingerprint_hash(type, hash, len)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_hmac_in-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_hmac_in","text":"ssh_get_hmac_in(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_hmac_out-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_hmac_out","text":"ssh_get_hmac_out(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_issue_banner-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_issue_banner","text":"ssh_get_issue_banner(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_kex_algo-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_kex_algo","text":"ssh_get_kex_algo(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_openssh_version-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_openssh_version","text":"ssh_get_openssh_version(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_poll_flags-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_poll_flags","text":"ssh_get_poll_flags(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_pubkey_hash-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_pubkey_hash","text":"ssh_get_pubkey_hash(session, hash)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_publickey-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_publickey","text":"ssh_get_publickey(session, key)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_publickey_hash-NTuple{4, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_publickey_hash","text":"ssh_get_publickey_hash(key, type, hash, hlen)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_server_publickey-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_server_publickey","text":"ssh_get_server_publickey(session, key)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_serverbanner-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_serverbanner","text":"ssh_get_serverbanner(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_status-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_status","text":"ssh_get_status(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_get_version-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_get_version","text":"ssh_get_version(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_is_blocking-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_is_blocking","text":"ssh_is_blocking(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_is_connected-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_is_connected","text":"ssh_is_connected(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_is_server_known-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_is_server_known","text":"ssh_is_server_known(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_known_hosts_parse_line-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_known_hosts_parse_line","text":"ssh_known_hosts_parse_line(host, line, entry)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_knownhosts_entry_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_knownhosts_entry_free","text":"ssh_knownhosts_entry_free(entry)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_new-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_new","text":"ssh_new()\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_options_copy-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_options_copy","text":"ssh_options_copy(src, dest)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_options_get-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_options_get","text":"ssh_options_get(session, type, value; throw = true)\n\nAuto-generated wrapper around ssh_options_get().\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_options_get_port-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_options_get_port","text":"ssh_options_get_port(session, port_target; throw = true)\n\nAuto-generated wrapper around ssh_options_get_port().\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_options_getopt-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_options_getopt","text":"ssh_options_getopt(session, argcptr, argv)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_options_parse_config-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_options_parse_config","text":"ssh_options_parse_config(session, filename)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_options_set-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_options_set","text":"ssh_options_set(session, type, value; throw = true)\n\nAuto-generated wrapper around ssh_options_set().\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_print_hash-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_print_hash","text":"ssh_print_hash(type, hash, len)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_request_no_more_sessions-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_request_no_more_sessions","text":"ssh_request_no_more_sessions(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_select-NTuple{5, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_select","text":"ssh_select(channels, outchannels, maxfd, readfds, timeout)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_send_debug-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_send_debug","text":"ssh_send_debug(session, message, always_display)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_send_ignore-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_send_ignore","text":"ssh_send_ignore(session, data)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_session_export_known_hosts_entry-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_session_export_known_hosts_entry","text":"ssh_session_export_known_hosts_entry(session, pentry_string)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_session_get_known_hosts_entry-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_session_get_known_hosts_entry","text":"ssh_session_get_known_hosts_entry(session, pentry)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_session_has_known_hosts_entry-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_session_has_known_hosts_entry","text":"ssh_session_has_known_hosts_entry(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_session_is_known_server-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_session_is_known_server","text":"ssh_session_is_known_server(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_session_set_disconnect_message-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_session_set_disconnect_message","text":"ssh_session_set_disconnect_message(session, message)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_session_update_known_hosts-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_session_update_known_hosts","text":"ssh_session_update_known_hosts(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_blocking-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_blocking","text":"ssh_set_blocking(session, blocking)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_counters-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_counters","text":"ssh_set_counters(session, scounter, rcounter)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_fd_except-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_fd_except","text":"ssh_set_fd_except(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_fd_toread-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_fd_toread","text":"ssh_set_fd_toread(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_set_fd_towrite-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_set_fd_towrite","text":"ssh_set_fd_towrite(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_silent_disconnect-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_silent_disconnect","text":"ssh_silent_disconnect(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_write_knownhost-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_write_knownhost","text":"ssh_write_knownhost(session)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Strings","page":"Low-level bindings","title":"Strings","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"string\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_string_burn-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_string_burn","text":"ssh_string_burn(str)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_string_copy-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_string_copy","text":"ssh_string_copy(str)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_string_data-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_string_data","text":"ssh_string_data(str)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_string_fill-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_string_fill","text":"ssh_string_fill(str, data, len)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_string_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_string_free","text":"ssh_string_free(str)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_string_free_char-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_string_free_char","text":"ssh_string_free_char(s)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_string_from_char-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_string_from_char","text":"ssh_string_from_char(what)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_string_get_char-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_string_get_char","text":"ssh_string_get_char(str)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_string_len-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_string_len","text":"ssh_string_len(str)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_string_new-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_string_new","text":"ssh_string_new(size)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_string_to_char-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_string_to_char","text":"ssh_string_to_char(str)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#SCP","page":"Low-level bindings","title":"SCP","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"scp\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_scp_accept_request-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_accept_request","text":"ssh_scp_accept_request(scp)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_close-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_close","text":"ssh_scp_close(scp)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_deny_request-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_deny_request","text":"ssh_scp_deny_request(scp, reason)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_free","text":"ssh_scp_free(scp)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_init-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_init","text":"ssh_scp_init(scp)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_leave_directory-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_leave_directory","text":"ssh_scp_leave_directory(scp)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_new-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_new","text":"ssh_scp_new(session, mode, location)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_pull_request-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_pull_request","text":"ssh_scp_pull_request(scp)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_push_directory-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_push_directory","text":"ssh_scp_push_directory(scp, dirname, mode)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_push_file-NTuple{4, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_push_file","text":"ssh_scp_push_file(scp, filename, size, perms)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_push_file64-NTuple{4, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_push_file64","text":"ssh_scp_push_file64(scp, filename, size, perms)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_read-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_read","text":"ssh_scp_read(scp, buffer, size)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_request_get_filename-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_request_get_filename","text":"ssh_scp_request_get_filename(scp)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_request_get_permissions-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_request_get_permissions","text":"ssh_scp_request_get_permissions(scp)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_request_get_size-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_request_get_size","text":"ssh_scp_request_get_size(scp)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_request_get_size64-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_request_get_size64","text":"ssh_scp_request_get_size64(scp)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_request_get_warning-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_request_get_warning","text":"ssh_scp_request_get_warning(scp)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_scp_write-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_scp_write","text":"ssh_scp_write(scp, buffer, len)\n\nUpstream documentation.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#SFTP","page":"Low-level bindings","title":"SFTP","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"sftp\")","category":"page"},{"location":"bindings/#LibSSH.lib.sftp_aio_begin_read-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_aio_begin_read","text":"sftp_aio_begin_read(file, len, aio)\n\nStart an asynchronous read from a file using an opened sftp file handle.\n\nIts goal is to avoid the slowdowns related to the request/response pattern of a synchronous read. To do so, you must call 2 functions :\n\nsftp_aio_begin_read() and sftp_aio_wait_read().\n\nThe first step is to call sftp_aio_begin_read(). This function sends a read request to the sftp server, dynamically allocates memory to store information about the sent request and provides the caller an sftp aio handle to that memory.\nThe second step is to call sftp_aio_wait_read() and pass it the address of a location storing the sftp aio handle provided by sftp_aio_begin_read().\n\nThese two functions do not close the open sftp file handle passed to sftp_aio_begin_read() irrespective of whether they fail or not.\n\nIt is the responsibility of the caller to ensure that the open sftp file handle passed to sftp_aio_begin_read() must not be closed before the corresponding call to sftp_aio_wait_read(). After sftp_aio_wait_read() returns, it is caller's decision whether to immediately close the file by calling sftp_close() or to keep it open and perform some more operations on it.\n\nThis function caps the length a user is allowed to read from an sftp file, the value of len parameter after capping is returned on success.\n\nThe value used for the cap is same as the value of the max_read_length field of the sftp_limits_t returned by sftp_limits().\n\nwarning: Warning\nWhen calling this function, the internal file offset is updated corresponding to the number of bytes requested to read.\n\nwarning: Warning\nA call to sftp_aio_begin_read() sends a request to the server. When the server answers, libssh allocates memory to store it until sftp_aio_wait_read() is called. Not calling sftp_aio_wait_read() will lead to memory leaks.\n\nArguments\n\nfile: The opened sftp file handle to be read from.\nlen: Number of bytes to read.\naio: Pointer to a location where the sftp aio handle (corresponding to the sent request) should be stored.\n\nReturns\n\nOn success, the number of bytes the server is requested to read (value of len parameter after capping). On error, SSH_ERROR with sftp and ssh errors set.\n\nSee also\n\nsftp_aio_wait_read(), sftp_aio_free(), sftp_open(), sftp_close(), sftp_get_error(), ssh_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_aio_begin_write-NTuple{4, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_aio_begin_write","text":"sftp_aio_begin_write(file, buf, len, aio)\n\nStart an asynchronous write to a file using an opened sftp file handle.\n\nIts goal is to avoid the slowdowns related to the request/response pattern of a synchronous write. To do so, you must call 2 functions :\n\nsftp_aio_begin_write() and sftp_aio_wait_write().\n\nThe first step is to call sftp_aio_begin_write(). This function sends a write request to the sftp server, dynamically allocates memory to store information about the sent request and provides the caller an sftp aio handle to that memory.\nThe second step is to call sftp_aio_wait_write() and pass it the address of a location storing the sftp aio handle provided by sftp_aio_begin_write().\n\nThese two functions do not close the open sftp file handle passed to sftp_aio_begin_write() irrespective of whether they fail or not.\n\nIt is the responsibility of the caller to ensure that the open sftp file handle passed to sftp_aio_begin_write() must not be closed before the corresponding call to sftp_aio_wait_write(). After sftp_aio_wait_write() returns, it is caller's decision whether to immediately close the file by calling sftp_close() or to keep it open and perform some more operations on it.\n\nThis function caps the length a user is allowed to write to an sftp file, the value of len parameter after capping is returned on success.\n\nThe value used for the cap is same as the value of the max_write_length field of the sftp_limits_t returned by sftp_limits().\n\nwarning: Warning\nWhen calling this function, the internal file offset is updated corresponding to the number of bytes requested to write.\n\nwarning: Warning\nA call to sftp_aio_begin_write() sends a request to the server. When the server answers, libssh allocates memory to store it until sftp_aio_wait_write() is called. Not calling sftp_aio_wait_write() will lead to memory leaks.\n\nArguments\n\nfile: The opened sftp file handle to write to.\nbuf: Pointer to the buffer containing data to write.\nlen: Number of bytes to write.\naio: Pointer to a location where the sftp aio handle (corresponding to the sent request) should be stored.\n\nReturns\n\nOn success, the number of bytes the server is requested to write (value of len parameter after capping). On error, SSH_ERROR with sftp and ssh errors set.\n\nSee also\n\nsftp_aio_wait_write(), sftp_aio_free(), sftp_open(), sftp_close(), sftp_get_error(), ssh_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_aio_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_aio_free","text":"sftp_aio_free(aio)\n\nDeallocate memory corresponding to a sftp aio handle.\n\nThis function deallocates memory corresponding to the aio handle returned by the sftp_aio_begin_*() functions. Users can use this function to free memory corresponding to an aio handle for an outstanding async i/o request on encountering some error.\n\nArguments\n\naio: sftp aio handle corresponding to which memory has to be deallocated.\n\nSee also\n\nsftp_aio_begin_read(), sftp_aio_wait_read(), sftp_aio_begin_write(), sftp_aio_wait_write()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_aio_wait_read-Tuple{Ptr{Ptr{LibSSH.lib.sftp_aio_struct}}, Ptr{Nothing}, UInt64}","page":"Low-level bindings","title":"LibSSH.lib.sftp_aio_wait_read","text":"sftp_aio_wait_read(aio::Ptr{sftp_aio}, buf::Ptr{Cvoid}, buf_size::Csize_t)\n\nAuto-generated wrapper around sftp_aio_wait_read(). Original upstream documentation is below.\n\n\n\nWait for an asynchronous read to complete and store the read data in the supplied buffer.\n\nA pointer to an sftp aio handle should be passed while calling this function. Except when the return value is SSH_AGAIN, this function releases the memory corresponding to the supplied aio handle and assigns NULL to that aio handle using the passed pointer to that handle.\n\nIf the file is opened in non-blocking mode and the request hasn't been executed yet, this function returns SSH_AGAIN and must be called again using the same sftp aio handle.\n\nwarning: Warning\nA call to this function with an invalid sftp aio handle may never return.\n\nArguments\n\naio: Pointer to the sftp aio handle returned by sftp_aio_begin_read().\nbuf: Pointer to the buffer in which read data will be stored.\nbuf_size: Size of the buffer in bytes. It should be bigger or equal to the length parameter of the sftp_aio_begin_read() call.\n\nReturns\n\nNumber of bytes read, 0 on EOF, SSH_ERROR if an error occurred, SSH_AGAIN if the file is opened in nonblocking mode and the request hasn't been executed yet.\n\nSee also\n\nsftp_aio_begin_read(), sftp_aio_free()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_aio_wait_write-Tuple{Ptr{Ptr{LibSSH.lib.sftp_aio_struct}}}","page":"Low-level bindings","title":"LibSSH.lib.sftp_aio_wait_write","text":"sftp_aio_wait_write(aio::Ptr{sftp_aio})\n\nAuto-generated wrapper around sftp_aio_wait_write(). Original upstream documentation is below.\n\n\n\nWait for an asynchronous write to complete.\n\nA pointer to an sftp aio handle should be passed while calling this function. Except when the return value is SSH_AGAIN, this function releases the memory corresponding to the supplied aio handle and assigns NULL to that aio handle using the passed pointer to that handle.\n\nIf the file is opened in non-blocking mode and the request hasn't been executed yet, this function returns SSH_AGAIN and must be called again using the same sftp aio handle.\n\nwarning: Warning\nA call to this function with an invalid sftp aio handle may never return.\n\nArguments\n\naio: Pointer to the sftp aio handle returned by sftp_aio_begin_write().\n\nReturns\n\nNumber of bytes written on success, SSH_ERROR if an error occurred, SSH_AGAIN if the file is opened in nonblocking mode and the request hasn't been executed yet.\n\nSee also\n\nsftp_aio_begin_write(), sftp_aio_free()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_async_read-NTuple{4, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_async_read","text":"sftp_async_read(file, data, len, id)\n\nWait for an asynchronous read to complete and save the data.\n\nwarning: Warning\nA call to this function with an invalid identifier will never return.\n\nArguments\n\nfile: The opened sftp file handle to be read from.\ndata: Pointer to buffer to receive read data.\nlen: Size of the buffer in bytes. It should be bigger or equal to the length parameter of the sftp_async_read_begin() call.\nid: The identifier returned by the sftp_async_read_begin() function.\n\nReturns\n\nNumber of bytes read, 0 on EOF, SSH_ERROR if an error occurred, SSH_AGAIN if the file is opened in nonblocking mode and the request hasn't been executed yet.\n\nSee also\n\nsftp_async_read_begin()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_async_read_begin-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_async_read_begin","text":"sftp_async_read_begin(file, len)\n\nStart an asynchronous read from a file using an opened sftp file handle.\n\nIts goal is to avoid the slowdowns related to the request/response pattern of a synchronous read. To do so, you must call 2 functions:\n\nsftp_async_read_begin() and sftp_async_read().\n\nThe first step is to call sftp_async_read_begin(). This function returns a request identifier. The second step is to call sftp_async_read() using the returned identifier.\n\nwarning: Warning\nWhen calling this function, the internal offset is updated corresponding to the len parameter.\n\nwarning: Warning\nA call to sftp_async_read_begin() sends a request to the server. When the server answers, libssh allocates memory to store it until sftp_async_read() is called. Not calling sftp_async_read() will lead to memory leaks.\n\nArguments\n\nfile: The opened sftp file handle to be read from.\nlen: Size to read in bytes.\n\nReturns\n\nAn identifier corresponding to the sent request, < 0 on error.\n\nSee also\n\nsftp_async_read(), sftp_open()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_attributes_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_attributes_free","text":"sftp_attributes_free(file)\n\nFree a sftp attribute structure.\n\nArguments\n\nfile: The sftp attribute structure to free.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_canonicalize_path-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_canonicalize_path","text":"sftp_canonicalize_path(sftp, path)\n\nCanonicalize a sftp path.\n\nArguments\n\nsftp: The sftp session handle.\npath: The path to be canonicalized.\n\nReturns\n\nA pointer to the newly allocated canonicalized path, NULL on error. The caller needs to free the memory using ssh_string_free_char().\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_chmod-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_chmod","text":"sftp_chmod(sftp, file, mode)\n\nChange permissions of a file\n\nArguments\n\nsftp: The sftp session handle.\nfile: The file which owner and group should be changed.\nmode: Specifies the permissions to use. It is modified by the process's umask in the usual way: The permissions of the created file are (mode & ~umask)\n\nReturns\n\n0 on success, < 0 on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_chown-NTuple{4, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_chown","text":"sftp_chown(sftp, file, owner, group)\n\nChange the file owner and group\n\nArguments\n\nsftp: The sftp session handle.\nfile: The file which owner and group should be changed.\nowner: The new owner which should be set.\ngroup: The new group which should be set.\n\nReturns\n\n0 on success, < 0 on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_close-Tuple{Ptr{LibSSH.lib.sftp_file_struct}}","page":"Low-level bindings","title":"LibSSH.lib.sftp_close","text":"sftp_close(file::sftp_file)\n\nAuto-generated wrapper around sftp_close(). Original upstream documentation is below.\n\n\n\nClose an open file handle.\n\nArguments\n\nfile: The open sftp file handle to close.\n\nReturns\n\nReturns SSH_NO_ERROR or SSH_ERROR if an error occurred.\n\nSee also\n\nsftp_open()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_closedir-Tuple{Ptr{LibSSH.lib.sftp_dir_struct}}","page":"Low-level bindings","title":"LibSSH.lib.sftp_closedir","text":"sftp_closedir(dir::sftp_dir)\n\nAuto-generated wrapper around sftp_closedir(). Original upstream documentation is below.\n\n\n\nClose a directory handle opened by sftp_opendir().\n\nArguments\n\ndir: The sftp directory handle to close.\n\nReturns\n\nReturns SSH_NO_ERROR or SSH_ERROR if an error occurred.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_dir_eof-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_dir_eof","text":"sftp_dir_eof(dir)\n\nTell if the directory has reached EOF (End Of File).\n\nArguments\n\ndir: The sftp directory handle.\n\nReturns\n\n1 if the directory is EOF, 0 if not.\n\nSee also\n\nsftp_readdir()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_expand_path-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_expand_path","text":"sftp_expand_path(sftp, path)\n\nCanonicalize path using expand-path.com extension\n\nArguments\n\nsftp: The sftp session handle.\npath: The path to be canonicalized.\n\nReturns\n\nA pointer to the newly allocated canonicalized path, NULL on error. The caller needs to free the memory using ssh_string_free_char().\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_extension_supported-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_extension_supported","text":"sftp_extension_supported(sftp, name, data)\n\nCheck if the given extension is supported.\n\nExample:\n\n sftp_extension_supported(sftp, \"statvfs@openssh.com\", \"2\");\n\nArguments\n\nsftp: The sftp session to use.\nname: The name of the extension.\ndata: The data of the extension.\n\nReturns\n\n1 if supported, 0 if not.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_extensions_get_count-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_extensions_get_count","text":"sftp_extensions_get_count(sftp)\n\nGet the count of extensions provided by the server.\n\nArguments\n\nsftp: The sftp session to use.\n\nReturns\n\nThe count of extensions provided by the server, 0 on error or not available.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_extensions_get_data-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_extensions_get_data","text":"sftp_extensions_get_data(sftp, indexn; throw = true)\n\nAuto-generated wrapper around sftp_extensions_get_data(). Original upstream documentation is below.\n\n\n\nGet the data of the extension provided by the server.\n\nThis is normally the version number of the extension.\n\nArguments\n\nsftp: The sftp session to use.\nindexn: The index number of the extension data you want.\n\nReturns\n\nThe data of the extension.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_extensions_get_name-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_extensions_get_name","text":"sftp_extensions_get_name(sftp, indexn; throw = true)\n\nAuto-generated wrapper around sftp_extensions_get_name(). Original upstream documentation is below.\n\n\n\nGet the name of the extension provided by the server.\n\nArguments\n\nsftp: The sftp session to use.\nindexn: The index number of the extension name you want.\n\nReturns\n\nThe name of the extension.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_file_set_blocking-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_file_set_blocking","text":"sftp_file_set_blocking(handle)\n\nMake the sftp communication for this file handle blocking.\n\nArguments\n\nhandle:[in] The file handle to set blocking.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_file_set_nonblocking-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_file_set_nonblocking","text":"sftp_file_set_nonblocking(handle)\n\nMake the sftp communication for this file handle non blocking.\n\nArguments\n\nhandle:[in] The file handle to set non blocking.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_free","text":"sftp_free(sftp)\n\nClose and deallocate a sftp session.\n\nArguments\n\nsftp: The sftp session handle to free.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_fstat-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_fstat","text":"sftp_fstat(file)\n\nGet information about a file or directory from a file handle.\n\nArguments\n\nfile: The sftp file handle to get the stat information.\n\nReturns\n\nThe sftp attributes structure of the file or directory, NULL on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_fstatvfs-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_fstatvfs","text":"sftp_fstatvfs(file)\n\nGet information about a mounted file system.\n\nArguments\n\nfile: An opened file.\n\nReturns\n\nA statvfs structure or NULL on error.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_fsync-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_fsync","text":"sftp_fsync(file)\n\nSynchronize a file's in-core state with storage device\n\nThis calls the \"fsync@openssh.com\" extension. You should check if the extensions is supported using:\n\n int supported = sftp_extension_supported(sftp, \"fsync@openssh.com\", \"1\");\n\nArguments\n\nfile: The opened sftp file handle to sync\n\nReturns\n\n0 on success, < 0 on error with ssh and sftp error set.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_get_error-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_get_error","text":"sftp_get_error(sftp)\n\nGet the last sftp error.\n\nUse this function to get the latest error set by a posix like sftp function.\n\nArguments\n\nsftp: The sftp session where the error is saved.\n\nReturns\n\nThe saved error (see server responses), < 0 if an error in the function occurred.\n\nSee also\n\nServer responses\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_hardlink-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_hardlink","text":"sftp_hardlink(sftp, oldpath, newpath)\n\nCreate a hard link.\n\nArguments\n\nsftp: The sftp session handle.\noldpath: Specifies the pathname of the file for which the new hardlink is to be created.\nnewpath: Specifies the pathname of the hardlink to be created.\n\nReturns\n\n0 on success, -1 on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_home_directory-Tuple{Ptr{LibSSH.lib.sftp_session_struct}, Ptr{Int8}}","page":"Low-level bindings","title":"LibSSH.lib.sftp_home_directory","text":"sftp_home_directory(sftp::sftp_session, username::Ptr{Cchar})\n\nAuto-generated wrapper around sftp_home_directory(). Original upstream documentation is below.\n\n\n\nGet the specified user's home directory\n\nThis calls the \"home-directory\" extension. You should check if the extension is supported using:\n\n int supported  = sftp_extension_supported(sftp, \"home-directory\", \"1\");\n\nArguments\n\nsftp: The sftp session handle.\nusername: username of the user whose home directory is requested.\n\nReturns\n\nOn success, a newly allocated string containing the absolute real-path of the home directory of the user. NULL on error. The caller needs to free the memory using ssh_string_free_char().\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_init-Tuple{Ptr{LibSSH.lib.sftp_session_struct}}","page":"Low-level bindings","title":"LibSSH.lib.sftp_init","text":"sftp_init(sftp::sftp_session)\n\nAuto-generated wrapper around sftp_init(). Original upstream documentation is below.\n\n\n\nInitialize the sftp protocol with the server.\n\nThis function involves the SFTP protocol initialization (as described in the SFTP specification), including the version and extensions negotiation.\n\nArguments\n\nsftp: The sftp session to initialize.\n\nReturns\n\n0 on success, < 0 on error with ssh error set.\n\nSee also\n\nsftp_new()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_limits-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_limits","text":"sftp_limits(sftp)\n\nGet information about the various limits the server might impose.\n\nArguments\n\nsftp: The sftp session handle.\n\nReturns\n\nA limits structure or NULL on error.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_limits_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_limits_free","text":"sftp_limits_free(limits)\n\nFree the memory of an allocated limits.\n\nArguments\n\nlimits: The limits to free.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_lsetstat-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_lsetstat","text":"sftp_lsetstat(sftp, file, attr)\n\nThis request is like setstat (excluding mode and size) but sets file attributes on symlinks themselves.\n\nNote, that this function can only set time values using 32 bit values due to the restrictions in the SFTP protocol version 3 implemented by libssh. The support for 64 bit time values was introduced in SFTP version 5, which is not implemented by libssh nor any major SFTP servers.\n\nArguments\n\nsftp: The sftp session handle.\nfile: The symbolic link which attributes should be changed.\nattr: The file attributes structure with the attributes set which should be changed.\n\nReturns\n\n0 on success, < 0 on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_lstat-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_lstat","text":"sftp_lstat(session, path)\n\nGet information about a file or directory.\n\nIdentical to sftp_stat, but if the file or directory is a symbolic link, then the link itself is stated, not the file that it refers to.\n\nArguments\n\nsession: The sftp session handle.\npath: The path to the file or directory to obtain the information.\n\nReturns\n\nThe sftp attributes structure of the file or directory, NULL on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_mkdir-Tuple{Ptr{LibSSH.lib.sftp_session_struct}, Ptr{Int8}, UInt32}","page":"Low-level bindings","title":"LibSSH.lib.sftp_mkdir","text":"sftp_mkdir(sftp::sftp_session, directory::Ptr{Cchar}, mode::mode_t)\n\nAuto-generated wrapper around sftp_mkdir(). Original upstream documentation is below.\n\n\n\nCreate a directory.\n\nArguments\n\nsftp: The sftp session handle.\ndirectory: The directory to create.\nmode: Specifies the permissions to use. It is modified by the process's umask in the usual way: The permissions of the created file are (mode & ~umask)\n\nReturns\n\n0 on success, < 0 on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_new-Tuple{Ptr{LibSSH.lib.ssh_session_struct}}","page":"Low-level bindings","title":"LibSSH.lib.sftp_new","text":"sftp_new(session::ssh_session)\n\nAuto-generated wrapper around sftp_new(). Original upstream documentation is below.\n\n\n\nCreates a new sftp session.\n\nThis function creates a new sftp session and allocates a new sftp channel with the server inside of the provided ssh session. This function call is usually followed by the sftp_init(), which initializes SFTP protocol itself.\n\nArguments\n\nsession: The ssh session to use.\n\nReturns\n\nA new sftp session or NULL on error.\n\nSee also\n\nsftp_free(), sftp_init()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_new_channel-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_new_channel","text":"sftp_new_channel(session, channel)\n\nStart a new sftp session with an existing channel.\n\nArguments\n\nsession: The ssh session to use.\nchannel:\tAn open session channel with subsystem already allocated\n\nReturns\n\nA new sftp session or NULL on error.\n\nSee also\n\nsftp_free()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_open-Tuple{Ptr{LibSSH.lib.sftp_session_struct}, Ptr{Int8}, Int32, UInt32}","page":"Low-level bindings","title":"LibSSH.lib.sftp_open","text":"sftp_open(session::sftp_session, file::Ptr{Cchar}, accesstype::Cint, mode::mode_t)\n\nAuto-generated wrapper around sftp_open(). Original upstream documentation is below.\n\n\n\nOpen a file on the server.\n\nArguments\n\nsession: The sftp session handle.\nfile: The file to be opened.\naccesstype: Is one of O_RDONLY, O_WRONLY or O_RDWR which request opening the file read-only,write-only or read/write. Acesss may also be bitwise-or'd with one or more of the following: O_CREAT - If the file does not exist it will be created. O_EXCL - When used with O_CREAT, if the file already exists it is an error and the open will fail. O_TRUNC - If the file already exists it will be truncated.\nmode: Mode specifies the permissions to use if a new file is created. It is modified by the process's umask in the usual way: The permissions of the created file are (mode & ~umask)\n\nReturns\n\nA sftp file handle, NULL on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_opendir-Tuple{Ptr{LibSSH.lib.sftp_session_struct}, Ptr{Int8}}","page":"Low-level bindings","title":"LibSSH.lib.sftp_opendir","text":"sftp_opendir(session::sftp_session, path::Ptr{Cchar})\n\nAuto-generated wrapper around sftp_opendir(). Original upstream documentation is below.\n\n\n\nOpen a directory used to obtain directory entries.\n\nArguments\n\nsession: The sftp session handle to open the directory.\npath: The path of the directory to open.\n\nReturns\n\nA sftp directory handle or NULL on error with ssh and sftp error set.\n\nSee also\n\nsftp_readdir, sftp_closedir\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_read-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_read","text":"sftp_read(file, buf, count)\n\nRead from a file using an opened sftp file handle.\n\nThis function caps the length a user is allowed to read from an sftp file.\n\nThe value used for the cap is same as the value of the max_read_length field of the sftp_limits_t returned by sftp_limits().\n\nArguments\n\nfile: The opened sftp file handle to be read from.\nbuf: Pointer to buffer to receive read data.\ncount: Size of the buffer in bytes.\n\nReturns\n\nNumber of bytes read, < 0 on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_readdir-Tuple{Ptr{LibSSH.lib.sftp_session_struct}, Ptr{LibSSH.lib.sftp_dir_struct}}","page":"Low-level bindings","title":"LibSSH.lib.sftp_readdir","text":"sftp_readdir(session::sftp_session, dir::sftp_dir)\n\nAuto-generated wrapper around sftp_readdir(). Original upstream documentation is below.\n\n\n\nGet a single file attributes structure of a directory.\n\nArguments\n\nsession: The sftp session handle to read the directory entry.\ndir: The opened sftp directory handle to read from.\n\nReturns\n\nA file attribute structure or NULL at the end of the directory.\n\nSee also\n\nsftp_opendir(), sftp_attribute_free(), sftp_closedir()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_readlink-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_readlink","text":"sftp_readlink(sftp, path)\n\nRead the value of a symbolic link.\n\nArguments\n\nsftp: The sftp session handle.\npath: Specifies the path name of the symlink to be read.\n\nReturns\n\nThe target of the link, NULL on error. The caller needs to free the memory using ssh_string_free_char().\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_rename-Tuple{Ptr{LibSSH.lib.sftp_session_struct}, Ptr{Int8}, Ptr{Int8}}","page":"Low-level bindings","title":"LibSSH.lib.sftp_rename","text":"sftp_rename(sftp::sftp_session, original::Ptr{Cchar}, newname::Ptr{Cchar})\n\nAuto-generated wrapper around sftp_rename(). Original upstream documentation is below.\n\n\n\nRename or move a file or directory.\n\nArguments\n\nsftp: The sftp session handle.\noriginal: The original url (source url) of file or directory to be moved.\nnewname: The new url (destination url) of the file or directory after the move.\n\nReturns\n\n0 on success, < 0 on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_rewind-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_rewind","text":"sftp_rewind(file)\n\nRewinds the position of the file pointer to the beginning of the file.\n\nArguments\n\nfile: Open sftp file handle.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_rmdir-Tuple{Ptr{LibSSH.lib.sftp_session_struct}, Ptr{Int8}}","page":"Low-level bindings","title":"LibSSH.lib.sftp_rmdir","text":"sftp_rmdir(sftp::sftp_session, directory::Ptr{Cchar})\n\nAuto-generated wrapper around sftp_rmdir(). Original upstream documentation is below.\n\n\n\nRemove a directory.\n\nArguments\n\nsftp: The sftp session handle.\ndirectory: The directory to remove.\n\nReturns\n\n0 on success, < 0 on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_seek-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_seek","text":"sftp_seek(file, new_offset)\n\nSeek to a specific location in a file.\n\nArguments\n\nfile: Open sftp file handle to seek in.\nnew_offset: Offset in bytes to seek.\n\nReturns\n\n0 on success, < 0 on error.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_seek64-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_seek64","text":"sftp_seek64(file, new_offset)\n\nSeek to a specific location in a file. This is the 64bit version.\n\nArguments\n\nfile: Open sftp file handle to seek in.\nnew_offset: Offset in bytes to seek.\n\nReturns\n\n0 on success, < 0 on error.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_server_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_server_free","text":"sftp_server_free(sftp)\n\nClose and deallocate a sftp server session.\n\nArguments\n\nsftp: The sftp session handle to free.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_server_init-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_server_init","text":"sftp_server_init(sftp)\n\nInitialize the sftp server.\n\nArguments\n\nsftp: The sftp session to init.\n\nReturns\n\n0 on success, < 0 on error.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_server_new-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_server_new","text":"sftp_server_new(session, chan)\n\nCreate a new sftp server session.\n\nArguments\n\nsession: The ssh session to use.\nchan: The ssh channel to use.\n\nReturns\n\nA new sftp server session.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_server_version-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_server_version","text":"sftp_server_version(sftp)\n\nGet the version of the SFTP protocol supported by the server\n\nArguments\n\nsftp: The sftp session handle.\n\nReturns\n\nThe server version.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_setstat-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_setstat","text":"sftp_setstat(sftp, file, attr)\n\nSet file attributes on a file, directory or symbolic link.\n\nNote, that this function can only set time values using 32 bit values due to the restrictions in the SFTP protocol version 3 implemented by libssh. The support for 64 bit time values was introduced in SFTP version 5, which is not implemented by libssh nor any major SFTP servers.\n\nArguments\n\nsftp: The sftp session handle.\nfile: The file which attributes should be changed.\nattr: The file attributes structure with the attributes set which should be changed.\n\nReturns\n\n0 on success, < 0 on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_stat-Tuple{Ptr{LibSSH.lib.sftp_session_struct}, Ptr{Int8}}","page":"Low-level bindings","title":"LibSSH.lib.sftp_stat","text":"sftp_stat(session::sftp_session, path::Ptr{Cchar})\n\nAuto-generated wrapper around sftp_stat(). Original upstream documentation is below.\n\n\n\nGet information about a file or directory.\n\nArguments\n\nsession: The sftp session handle.\npath: The path to the file or directory to obtain the information.\n\nReturns\n\nThe sftp attributes structure of the file or directory, NULL on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_statvfs-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_statvfs","text":"sftp_statvfs(sftp, path)\n\nGet information about a mounted file system.\n\nArguments\n\nsftp: The sftp session handle.\npath: The pathname of any file within the mounted file system.\n\nReturns\n\nA statvfs structure or NULL on error.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_statvfs_free-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_statvfs_free","text":"sftp_statvfs_free(statvfs_o)\n\nFree the memory of an allocated statvfs.\n\nArguments\n\nstatvfs_o: The statvfs to free.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_symlink-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_symlink","text":"sftp_symlink(sftp, target, dest)\n\nCreate a symbolic link.\n\nArguments\n\nsftp: The sftp session handle.\ntarget: Specifies the target of the symlink.\ndest: Specifies the path name of the symlink to be created.\n\nReturns\n\n0 on success, < 0 on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_tell-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_tell","text":"sftp_tell(file)\n\nReport current byte position in file.\n\nArguments\n\nfile: Open sftp file handle.\n\nReturns\n\nThe offset of the current byte relative to the beginning of the file associated with the file descriptor. < 0 on error.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_tell64-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_tell64","text":"sftp_tell64(file)\n\nReport current byte position in file.\n\nArguments\n\nfile: Open sftp file handle.\n\nReturns\n\nThe offset of the current byte relative to the beginning of the file associated with the file descriptor.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_unlink-Tuple{Ptr{LibSSH.lib.sftp_session_struct}, Ptr{Int8}}","page":"Low-level bindings","title":"LibSSH.lib.sftp_unlink","text":"sftp_unlink(sftp::sftp_session, file::Ptr{Cchar})\n\nAuto-generated wrapper around sftp_unlink(). Original upstream documentation is below.\n\n\n\nUnlink (delete) a file.\n\nArguments\n\nsftp: The sftp session handle.\nfile: The file to unlink/delete.\n\nReturns\n\n0 on success, < 0 on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_utimes-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_utimes","text":"sftp_utimes(sftp, file, times)\n\nChange the last modification and access time of a file.\n\nArguments\n\nsftp: The sftp session handle.\nfile: The file which owner and group should be changed.\ntimes: A timeval structure which contains the desired access and modification time.\n\nReturns\n\n0 on success, < 0 on error with ssh and sftp error set.\n\nSee also\n\nsftp_get_error()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_write-Tuple{Any, Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.sftp_write","text":"sftp_write(file, buf, count)\n\nWrite to a file using an opened sftp file handle.\n\nThis function caps the length a user is allowed to write to an sftp file.\n\nThe value used for the cap is same as the value of the max_write_length field of the sftp_limits_t returned by sftp_limits().\n\nArguments\n\nfile: Open sftp file handle to write to.\nbuf: Pointer to buffer to write data.\ncount: Size of buffer in bytes.\n\nReturns\n\nNumber of bytes written, < 0 on error with ssh and sftp error set.\n\nSee also\n\nsftp_open(), sftp_read(), sftp_close()\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Threading","page":"Low-level bindings","title":"Threading","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\nFilter = x -> group_filter(x, \"threads\")","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_threads_get_default-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_threads_get_default","text":"ssh_threads_get_default()\n\nReturns a pointer to the appropriate callbacks structure for the environment, to be used with ssh_threads_set_callbacks.\n\nReturns\n\nA pointer to a ssh_threads_callbacks_struct to be used with ssh_threads_set_callbacks.\n\nSee also\n\nssh_threads_set_callbacks\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_threads_get_noop-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_threads_get_noop","text":"ssh_threads_get_noop()\n\nGet the noop threads callbacks structure\n\nThis can be used with ssh_threads_set_callbacks. These callbacks do nothing and are being used by default.\n\nReturns\n\nAlways returns a valid pointer to the noop callbacks structure.\n\nSee also\n\nssh_threads_set_callbacks\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_threads_get_pthread-Tuple{}","page":"Low-level bindings","title":"LibSSH.lib.ssh_threads_get_pthread","text":"ssh_threads_get_pthread()\n\nReturns a pointer on the pthread threads callbacks, to be used with ssh_threads_set_callbacks.\n\nSee also\n\nssh_threads_set_callbacks\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_threads_set_callbacks-Tuple{Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_threads_set_callbacks","text":"ssh_threads_set_callbacks(cb)\n\nSet the thread callbacks structure.\n\nThis is necessary if your program is using libssh in a multithreaded fashion. This function must be called first, outside of any threading context (in your main() function for instance), before you call ssh_init().\n\ndanger: Known bug\nlibgcrypt 1.6 and bigger backend does not support custom callback. Using anything else than pthreads here will fail.\n\nArguments\n\ncb:[in] A pointer to a ssh_threads_callbacks_struct structure, which contains the different callbacks to be set.\n\nReturns\n\nAlways returns SSH_OK.\n\nSee also\n\nssh_threads_callbacks_struct, SSH_THREADS_PTHREAD\n\n\n\n\n\n","category":"method"},{"location":"bindings/#Other","page":"Low-level bindings","title":"Other","text":"","category":"section"},{"location":"bindings/","page":"Low-level bindings","title":"Low-level bindings","text":"Modules = [LibSSH.lib]\nOrder = [:function, :type, :constant]\n# Note that we document LibSSHException in api.md\nFilter = x -> group_filter(x, nothing) && nameof(x) != :LibSSHException","category":"page"},{"location":"bindings/#LibSSH.lib.ssh_message_auth_interactive_request-NTuple{6, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_auth_interactive_request","text":"ssh_message_auth_interactive_request(msg, name, instruction, num_prompts, prompts, echo)\n\nInitiate keyboard-interactive authentication from a server.\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.ssh_message_auth_reply_success-Tuple{Any, Any}","page":"Low-level bindings","title":"LibSSH.lib.ssh_message_auth_reply_success","text":"ssh_message_auth_reply_success(msg, partial; throw = true)\n\nAuto-generated wrapper around ssh_message_auth_reply_success().\n\n\n\n\n\n","category":"method"},{"location":"bindings/#LibSSH.lib.sftp_limits_struct","page":"Low-level bindings","title":"LibSSH.lib.sftp_limits_struct","text":"sftp_limits_struct\n\nSFTP limits structure.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.sftp_limits_t","page":"Low-level bindings","title":"LibSSH.lib.sftp_limits_t","text":"Pointer to a sftp_limits_struct\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.sftp_statvfs_struct","page":"Low-level bindings","title":"LibSSH.lib.sftp_statvfs_struct","text":"sftp_statvfs_struct\n\nSFTP statvfs structure.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_auth_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_auth_callback","text":"SSH authentication callback for password and publickey auth.\n\nArguments\n\nprompt: Prompt to be displayed.\nbuf: Buffer to save the password. You should null-terminate it.\nlen: Length of the buffer.\necho: Enable or disable the echo of what you type.\nverify: Should the password be verified?\nuserdata: Userdata to be passed to the callback function. Useful for GUI applications.\n\nReturns\n\n0 on success, < 0 on error.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_auth_gssapi_mic_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_auth_gssapi_mic_callback","text":"SSH authentication callback. Tries to authenticates user with the \"gssapi-with-mic\" method\n\nwarning: Warning\nImplementations should verify that parameter user matches in some way the principal. user and principal can be different. Only the latter is guaranteed to be safe.\n\nArguments\n\nsession: Current session handler\nuser: Username of the user (can be spoofed)\nprincipal: Authenticated principal of the user, including realm.\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\nSSH_AUTH_DENIED Authentication failed.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_auth_none_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_auth_none_callback","text":"SSH authentication callback. Tries to authenticates user with the \"none\" method which is anonymous or passwordless.\n\nArguments\n\nsession: Current session handler\nuser: User that wants to authenticate\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\nSSH_AUTH_DENIED Authentication failed.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_auth_password_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_auth_password_callback","text":"SSH authentication callback.\n\nArguments\n\nsession: Current session handler\nuser: User that wants to authenticate\npassword: Password used for authentication\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\nSSH_AUTH_DENIED Authentication failed.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_auth_pubkey_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_auth_pubkey_callback","text":"SSH authentication callback.\n\nArguments\n\nsession: Current session handler\nuser: User that wants to authenticate\npubkey: public key used for authentication\nsignature_state: SSH_PUBLICKEY_STATE_NONE if the key is not signed (simple public key probe),\tSSH_PUBLICKEY_STATE_VALID if the signature is valid. Others values should be\treplied with a SSH_AUTH_DENIED.\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\nSSH_AUTH_DENIED Authentication failed.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_bind","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind","text":"Server struct\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_bind_callbacks","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_callbacks","text":"Callbacks for a ssh_bind (upstream documentation).\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_bind_callbacks_struct","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_callbacks_struct","text":"ssh_bind_callbacks_struct\n\nThese are the callbacks exported by the ssh_bind structure.\n\nThey are called by the server module when events appear on the network.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_bind_incoming_connection_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_bind_incoming_connection_callback","text":"Incoming connection callback. This callback is called when a ssh_bind has a new incoming connection.\n\nArguments\n\nsshbind: Current sshbind session handler\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_callback_data","page":"Low-level bindings","title":"LibSSH.lib.ssh_callback_data","text":" @brief callback for data received messages.\n @param data data retrieved from the socket or stream\n @param len number of bytes available from this stream\n @param user user-supplied pointer sent along with all callback messages\n @returns number of bytes processed by the callee. The remaining bytes will\n be sent in the next callback message, when more data is available.\n \n\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_callback_int","page":"Low-level bindings","title":"LibSSH.lib.ssh_callback_int","text":" @brief callback to process simple codes\n @param code value to transmit\n @param user Userdata to pass in callback\n \n\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_callbacks_struct","page":"Low-level bindings","title":"LibSSH.lib.ssh_callbacks_struct","text":"ssh_callbacks_struct\n\nThe structure to replace libssh functions with appropriate callbacks.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_auth_agent_req_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_auth_agent_req_callback","text":"SSH auth-agent-request from the client. This request is sent by a client when agent forwarding is available. Server is free to ignore this callback, no answer is expected.\n\nArguments\n\nsession: the session\nchannel: the channel\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_close_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_close_callback","text":"SSH channel close callback. Called when a channel is closed by remote peer\n\nArguments\n\nsession: Current session handler\nchannel: the actual channel\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_data_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_data_callback","text":"SSH channel data callback. Called when data is available on a channel\n\nArguments\n\nsession: Current session handler\nchannel: the actual channel\ndata: the data that has been read on the channel\nlen: the length of the data\nis_stderr: is 0 for stdout or 1 for stderr\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\nnumber of bytes processed by the callee. The remaining bytes will be sent in the next callback message, when more data is available.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_env_request_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_env_request_callback","text":"SSH channel environment request from a client.\n\nwarning: Warning\nsome environment variables can be dangerous if changed (e.g. LD_PRELOAD) and should not be fulfilled.\n\nArguments\n\nsession: the session\nchannel: the channel\nenv_name: name of the environment value to be set\nenv_value: value of the environment value to be set\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\n1 if the request is denied\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_eof_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_eof_callback","text":"SSH channel eof callback. Called when a channel receives EOF\n\nArguments\n\nsession: Current session handler\nchannel: the actual channel\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_exec_request_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_exec_request_callback","text":"SSH channel Exec request from a client.\n\nArguments\n\nsession: the session\nchannel: the channel\ncommand: the shell command to be executed\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\n1 if the request is denied\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_exit_signal_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_exit_signal_callback","text":"SSH channel exit signal callback. Called when a channel has received an exit signal\n\nArguments\n\nsession: Current session handler\nchannel: the actual channel\nsignal: the signal name (without the SIG prefix)\ncore: a boolean telling whether a core has been dumped or not\nerrmsg: the description of the exception\nlang: the language of the description (format: RFC 3066)\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_exit_status_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_exit_status_callback","text":"SSH channel exit status callback. Called when a channel has received an exit status\n\nArguments\n\nsession: Current session handler\nchannel: the actual channel\nexit_status: Exit status of the ran command\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_open_request_auth_agent_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_open_request_auth_agent_callback","text":"Handles an SSH new channel open \"auth-agent\" request. This happens when the server sends back an \"auth-agent\" connection attempt. This is a client-side API\n\nwarning: Warning\nThe channel pointer returned by this callback must be closed by the application.\n\nArguments\n\nsession: current session handler\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\nNULL if the request should not be allowed\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_open_request_forwarded_tcpip_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_open_request_forwarded_tcpip_callback","text":"Handles an SSH new channel open \"forwarded-tcpip\" request. This happens when the server forwards an incoming TCP connection on a port it was previously requested to listen on. This is a client-side API\n\nwarning: Warning\nThe channel pointer returned by this callback must be closed by the application.\n\nArguments\n\nsession: current session handler\ndestination_address: the address that the TCP connection connected to\ndestination_port: the port that the TCP connection connected to\noriginator_address: the originator IP address\noriginator_port: the originator port\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\nNULL if the request should not be allowed\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_open_request_session_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_open_request_session_callback","text":"Handles an SSH new channel open session request\n\nwarning: Warning\nThe channel pointer returned by this callback must be closed by the application.\n\nArguments\n\nsession: current session handler\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\nNULL if the request should not be allowed\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_open_request_x11_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_open_request_x11_callback","text":"Handles an SSH new channel open X11 request. This happens when the server sends back an X11 connection attempt. This is a client-side API\n\nwarning: Warning\nThe channel pointer returned by this callback must be closed by the application.\n\nArguments\n\nsession: current session handler\nuserdata: Userdata to be passed to the callback function.\noriginator_address: IP address of the machine who sent the request\noriginator_port: port number of the machine who sent the request\n\nReturns\n\nNULL if the request should not be allowed\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_open_resp_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_open_resp_callback","text":"SSH channel open callback. Called when a channel open succeeds or fails.\n\nArguments\n\nsession: Current session handler\nchannel: the actual channel\nis_success: is 1 when the open succeeds, and 0 otherwise.\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_pty_request_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_pty_request_callback","text":"SSH channel PTY request from a client.\n\nArguments\n\nsession: the session\nchannel: the channel\nterm: The type of terminal emulation\nwidth: width of the terminal, in characters\nheight: height of the terminal, in characters\npxwidth: width of the terminal, in pixels\npwheight: height of the terminal, in pixels\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\n-1 if the request is denied\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_pty_window_change_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_pty_window_change_callback","text":"SSH channel PTY windows change (terminal size) from a client.\n\nArguments\n\nsession: the session\nchannel: the channel\nwidth: width of the terminal, in characters\nheight: height of the terminal, in characters\npxwidth: width of the terminal, in pixels\npwheight: height of the terminal, in pixels\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\n-1 if the request is denied\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_request_resp_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_request_resp_callback","text":"SSH channel request response callback. Called when a response to the pending request is received.\n\nArguments\n\nsession: Current session handler\nchannel: the actual channel\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_shell_request_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_shell_request_callback","text":"SSH channel Shell request from a client.\n\nArguments\n\nsession: the session\nchannel: the channel\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\n1 if the request is denied\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_signal_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_signal_callback","text":"SSH channel signal callback. Called when a channel has received a signal\n\nArguments\n\nsession: Current session handler\nchannel: the actual channel\nsignal: the signal name (without the SIG prefix)\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_subsystem_request_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_subsystem_request_callback","text":"SSH channel subsystem request from a client.\n\nArguments\n\nsession: the session\nchannel: the channel\nsubsystem: the subsystem required\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\n1 if the request is denied\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_write_wontblock_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_write_wontblock_callback","text":"SSH channel write will not block (flow control).\n\nArguments\n\nsession: the session\nchannel: the channel\nbytes:[in] size of the remote window in bytes. Writing as much data will not block.\nuserdata:[in] Userdata to be passed to the callback function.\n\nReturns\n\n0 default return value (other return codes may be added in future).\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_channel_x11_req_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_channel_x11_req_callback","text":"SSH X11 request from the client. This request is sent by a client when X11 forwarding is requested(and available). Server is free to ignore this callback, no answer is expected.\n\nArguments\n\nsession: the session\nchannel: the channel\nsingle_connection: If true, only one channel should be forwarded\nauth_protocol: The X11 authentication method to be used\nauth_cookie: Authentication cookie encoded hexadecimal\nscreen_number: Screen number\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_control_master_options_e","page":"Low-level bindings","title":"LibSSH.lib.ssh_control_master_options_e","text":"ssh_control_master_options_e\n\n@}\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_file_format_e","page":"Low-level bindings","title":"LibSSH.lib.ssh_file_format_e","text":"ssh_file_format_e\n\n@}\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_global_request_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_global_request_callback","text":"SSH global request callback. All global request will go through this callback.\n\nArguments\n\nsession: Current session handler\nmessage: the actual message\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_jump_authenticate_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_jump_authenticate_callback","text":"SSH proxyjump user authentication callback. Authenticate the user.\n\nArguments\n\nsession: Jump session handler\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\n0 on success, < 0 on error.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_jump_before_connection_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_jump_before_connection_callback","text":"SSH proxyjump before connection callback. Called before calling ssh_connect()\n\nArguments\n\nsession: Jump session handler\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\n0 on success, < 0 on error.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_jump_verify_knownhost_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_jump_verify_knownhost_callback","text":"SSH proxyjump verify knownhost callback. Verify the host. If not specified default function will be used.\n\nArguments\n\nsession: Jump session handler\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\n0 on success, < 0 on error.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_log_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_log_callback","text":"SSH log callback. All logging messages will go through this callback\n\nArguments\n\nsession: Current session handler\npriority: Priority of the log, the smaller being the more important\nmessage: the actual message\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_logging_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_logging_callback","text":"SSH log callback.\n\nAll logging messages will go through this callback.\n\nArguments\n\npriority: Priority of the log, the smaller being the more important.\nfunction: The function name calling the logging functions.\nbuffer: The actual message\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_packet_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_packet_callback","text":"Prototype for a packet callback, to be called when a new packet arrives\n\nArguments\n\nsession: The current session of the packet\ntype: packet type (see ssh2.h)\npacket: buffer containing the packet, excluding size, type and padding fields\nuser: user argument to the callback and are called each time a packet shows up\n\nReturns\n\nSSH_PACKET_NOT_USED Packet was not used or understood, processing must continue\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_server_callbacks_struct","page":"Low-level bindings","title":"LibSSH.lib.ssh_server_callbacks_struct","text":"ssh_server_callbacks_struct\n\nThis structure can be used to implement a libssh server, with appropriate callbacks.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_service_request_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_service_request_callback","text":"Handles an SSH service request\n\nArguments\n\nsession: current session handler\nservice: name of the service (e.g. \"ssh-userauth\") requested\nuserdata: Userdata to be passed to the callback function.\n\nReturns\n\n-1 if the request should not be allowed\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_session","page":"Low-level bindings","title":"LibSSH.lib.ssh_session","text":"Session struct (upstream documentation).\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_socket_callbacks_struct","page":"Low-level bindings","title":"LibSSH.lib.ssh_socket_callbacks_struct","text":"ssh_socket_callbacks_struct\n\nThese are the callbacks exported by the socket structure They are called by the socket module when a socket event appears\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_status_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_status_callback","text":"SSH Connection status callback.\n\nArguments\n\nsession: Current session handler\nstatus: Percentage of connection status, going from 0.0 to 1.0 once connection is done.\nuserdata: Userdata to be passed to the callback function.\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_thread_callback","page":"Low-level bindings","title":"LibSSH.lib.ssh_thread_callback","text":"libssh_threads\n\n@{\n\n\n\n\n\n","category":"type"},{"location":"bindings/#LibSSH.lib.ssh_threads_callbacks_struct","page":"Low-level bindings","title":"LibSSH.lib.ssh_threads_callbacks_struct","text":"ssh_threads_callbacks_struct\n\nThreads callbacks. See ssh_threads_set_callbacks\n\n\n\n\n\n","category":"type"}]
}
